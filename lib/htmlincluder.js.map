{"version":3,"sources":["webpack:///htmlincluder.js","webpack:///webpack/bootstrap f9718fd9affc52bb7c24","webpack:///./src/config.js","webpack:///./src/attributes/index.js","webpack:///./src/util/parsing.js","webpack:///./src/json/index.js","webpack:///./src/util/file.js","webpack:///./src/index.js","webpack:///./src/tags/clip.js","webpack:///./src/tags/index.js","webpack:///./src/util/platform.js","webpack:///./src/tags/data.js","webpack:///./src/tags/each.js","webpack:///./src/tags/if.js","webpack:///./src/tags/insert.js","webpack:///./src/tags/jsonInsert.js","webpack:///./src/tags/wrap.js"],"names":["e","a","i","exports","modules","__webpack_require__","moduleId","installedModules","module","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","value","wrapFiles","insertFiles","pageFiles","options","devOptions","insertPattern","filePathAttribute","jsonPathAttribute","configureFiles","file","path","push","setOptions","ops","dev","hasTagAttribute","attr","content","indexOf","getTagAttribute","fndx","lndx","console","warn","slice","length","setTagAttribute","left","right","changeTagAttributeName","newAttr","removeTagAttribute","middle","error","addTagAttribute","getDataFromJsonPath","jsonPath","jsonObj","result","json","_config","jsonInput","split","reduce","acc","cur","Array","isArray","_typeof","_json","toSafeJsonString","getIndexOfClosingBrace","startPattern","endPattern","tagDepth","tmpContent","substr","nextCloseNdx","nextOpenNdx","tmpOpen","tmpClosed","splitContent","tag","arr","openNdx","partial","closeNdx","findIndexOfClosingTag","openTag","closeTag","startNdx","endNdx","openCount","fragment","CONTENT_NDX","Symbol","iterator","obj","constructor","JSON","stringify","replace","processRawJson","jsonString","jsonData","eval","appendJsonParentPath","jsonParentPath","_parsing","map","ndx","join","addRawJsonWhereJsonPath","rawJson","data","bluntDataTagsInEaches","_attributes","unbluntDataTagsInEaches","eachLevel","File","f","contents","toString","trim","processed","_platform","isWin","fixFilePathForOS","buildPathFromRelativePath","cdir","fdir","dir","dirChar","pop","forEach","printPaths","log","updateRelativePaths","_interopRequireDefault","default","_clip","_clip2","_tags","_tags2","_file","initialize","hashFile","buildFileResult","callback","processClip","tmp","splice","processContent","jsonContext","splitArr","itterCount","contentBeforeProcessing","processSplitArray","printIterations","limitIterations","printResult","tempDirectory","pathStack","hasPath","hasAbsPath","curFile","tmpPath","_data2","_jsonInsert2","fileInfo","_insert2","flattenInsertedContent","_processWraps","_wrap2","_processWraps2","_slicedToArray","_if2","_each2","flattenEach","_fragment$i","_fileInfo","sliceIterator","_arr","_n","_d","_e","undefined","_s","_i","next","done","err","TypeError","_data","_each","_if","_insert","_jsonInsert","_wrap","test","process","platform","processDataTag","defaultValue","processEach","count","parseInt","middleMaster","processIf","processInsert","filename","processJsonInsert","processWraps","fpath","pattern"],"mappings":"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","file":"htmlincluder.js","sourcesContent":["(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar wrapFiles = exports.wrapFiles = {};\nvar insertFiles = exports.insertFiles = {};\nvar pageFiles = exports.pageFiles = [];\n\nvar options = exports.options = {};\nvar devOptions = exports.devOptions = {};\nvar insertPattern = exports.insertPattern = void 0;\nvar filePathAttribute = exports.filePathAttribute = void 0;\nvar jsonPathAttribute = exports.jsonPathAttribute = void 0;\n\nvar configureFiles = exports.configureFiles = function configureFiles(file) {\n  if (file.name[0] === '_') wrapFiles[file.path] = file;else if (file.name[0] === '-') insertFiles[file.path] = file;else pageFiles.push(file);\n};\n\n// @options = (optional) options for configuring htmlIncluder\n// options.jsonInput         = A json object used to populate data in files\n// options.insertPattern     = The test looked for in order to insert files\n//          (this is so ssi includes can be used instead)\n// options.filePathAttribute = the name used for the file pathing for #insert\n//          and #wrap (default= 'path')\n// options.jsonPathAttribute = the name used for the file pathing for #insert\n//          , #wrap, #data, #jsonInsert (default= 'jsonPath')\n//\n//\n// options.dev.limitIterations = the number of times processFileWithJsonInput will loop\n// options.dev.printIterations = console log each processFileWithJsonInput loop\n// options.dev.printResult = console logs the final output\n// options.dev.printPaths = console logs the output of buildPathFromRelativePath\nvar setOptions = exports.setOptions = function setOptions(ops) {\n  exports.devOptions = devOptions = ops.dev || {};\n  exports.options = options = ops;\n\n  //set text value for insert tags, or default\n  exports.insertPattern = insertPattern = options.insertPattern ? '<!--#' + options.insertPattern : '<!--#insert';\n\n  exports.filePathAttribute = filePathAttribute = options.filePathAttribute ? options.filePathAttribute : 'path';\n\n  exports.jsonPathAttribute = jsonPathAttribute = options.jsonPathAttribute ? options.jsonPathAttribute : 'jsonPath';\n};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasTagAttribute = hasTagAttribute;\nexports.getTagAttribute = getTagAttribute;\nexports.setTagAttribute = setTagAttribute;\nexports.changeTagAttributeName = changeTagAttributeName;\nexports.removeTagAttribute = removeTagAttribute;\nexports.addTagAttribute = addTagAttribute;\n// does a tag have an attribute? (attributeName=\"value\")\nfunction hasTagAttribute(attr, content) {\n  // strip out inner tags\n  // check attribute existence\n  return content.indexOf(attr + '=\"') > -1;\n}\n\n// get the value of an attribute (attributeName=\"value\")\nfunction getTagAttribute(attr, content) {\n  var fndx = -1,\n      lndx = -1;\n\n  fndx = content.indexOf(attr + '=\"');\n  if (fndx === -1) {\n    console.warn(\"Warning: no tag of name `\" + attr + \"` found in the following content: `\" + content + \"`\");\n    return \"\";\n  }\n\n  content = content.slice(fndx + attr.length + 2);\n  lndx = content.indexOf('\"');\n  content = content.slice(0, lndx);\n  return content;\n}\n\n// set the value of an attribute (attributeName=\"value\")\nfunction setTagAttribute(attr, content, value) {\n  var fndx = -1,\n      lndx = -1,\n      left = \"\",\n      right = \"\";\n\n  fndx = content.indexOf(attr + '=\"');\n  left = content.slice(0, fndx + attr.length + 2);\n  content = content.slice(fndx + attr.length + 2);\n  lndx = content.indexOf('\"');\n  right = content.slice(lndx);\n  content = left + value + right;\n  return content;\n}\n\n// rename one attribute name to another (attributeName=\"value\")\nfunction changeTagAttributeName(attr, content, newAttr) {\n  var fndx = -1,\n      lndx = -1,\n      left = \"\",\n      right = \"\";\n\n  fndx = content.indexOf(attr + '=\"');\n  left = content.slice(0, fndx);\n  right = content.slice(fndx + attr.length);\n  return left + newAttr + right;\n}\n\n// removes an attribute from a tag along with its value (attributeName=\"value\")\nfunction removeTagAttribute(attr, content) {\n  var fndx = -1,\n      lndx = -1,\n      left = \"\",\n      right = \"\",\n      middle = content;\n\n  if (hasTagAttribute(attr, middle)) {\n    fndx = middle.indexOf(attr + '=\"');\n    left = middle.slice(0, fndx);\n    right = middle.slice(fndx + attr.length + 2);\n    // really naive for now - just look for another '\"'\n    lndx = right.indexOf('\"');\n    if (lndx === -1) {\n      console.error('ERROR: No close `\"` in tag ' + content);\n      return content;\n    } else {\n      right = right.slice(lndx + 1);\n      middle = \"\";\n    }\n  }\n  return left + middle + right;\n}\n\n// adds an attribute from a tag along with a value (attributeName=\"value\")\nfunction addTagAttribute(attr, content, value) {\n  var fndx = -1,\n      lndx = -1,\n      left = \"\",\n      right = \"\",\n      middle = content;\n\n  lndx = middle.indexOf(\" \");\n  if (lndx > -1) {\n    left = middle.slice(0, lndx);\n    right = middle.slice(lndx);\n    middle = ' ' + attr + '=\"' + value + '\"';\n  }\n\n  return left + middle + right;\n}\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.getDataFromJsonPath = getDataFromJsonPath;\nexports.getIndexOfClosingBrace = getIndexOfClosingBrace;\nexports.splitContent = splitContent;\nexports.findIndexOfClosingTag = findIndexOfClosingTag;\n\nvar _json = __webpack_require__(3);\n\nvar _config = __webpack_require__(0);\n\n// given a jsonObject and a path, return the data pointed at\nfunction getDataFromJsonPath(jsonPath, jsonObj) {\n  var json = jsonObj || _config.options.jsonInput;\n  var result;\n\n  if (jsonPath === '*') return _config.options.jsonInput;\n  if (jsonPath === 'this') return json;\n  result = jsonPath.split('.').reduce(function (acc, cur) {\n    return acc ? acc[cur] : '';\n  }, json);\n\n  if (Array.isArray(result)) ;else if ((typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object') result = (0, _json.toSafeJsonString)(result);\n\n  return result;\n}\n\n// Given some content (starting with a tag) find the index after the end tag\nfunction getIndexOfClosingBrace(content, startPattern, endPattern) {\n  var tagDepth = 0; // when this gets to 0 we are done\n  var tmpContent = content.substr(1);\n\n  // prime loop by finding next start tag\n  var nextCloseNdx = tmpContent.indexOf(endPattern);\n  var nextOpenNdx = tmpContent.indexOf(startPattern);\n\n  if (nextCloseNdx === -1) console.error('No Close tag');\n\n  // if there is a nextCloseNdx, but no openNdx, return the end of the tag.\n  if (nextOpenNdx === -1 || nextOpenNdx > nextCloseNdx) return nextCloseNdx + 4;\n\n  // Now we know that we have an inner tag ... or should if the syntax is correct\n\n  // we found an open tag, so we need a close tag. Set depth to 1\n  tagDepth = 1;\n\n  // add 1 so we will search passed the tag\n  nextOpenNdx += 1;\n  nextCloseNdx += 1;\n\n  // while current tag is not closed...\n  do {\n    var tmpOpen = void 0,\n        tmpClosed = void 0;\n\n    // start tag is before close tag, then\n    // we can look to see if there is yet another tag nested between\n    if (nextOpenNdx > -1 && nextOpenNdx < nextCloseNdx) {\n      tmpOpen = tmpContent.substr(nextOpenNdx).indexOf(startPattern);\n      // see if we found something, and add this new index to our accumulator\n      if (tmpOpen > -1) {\n        // add 1 because we need next search to be beyond this tag\n        nextOpenNdx += tmpOpen + 2;\n        tagDepth += 1;\n      } else nextOpenNdx = -1;\n    } else {\n      // current close tag is before start tag\n      tmpClosed = tmpContent.substr(nextCloseNdx).indexOf(endPattern);\n      // see if we found something, and add this new index to our accumulator\n      if (tmpClosed > -1) {\n        // add 1 because we need next search to be beyond this tag\n        nextCloseNdx += tmpClosed + 2;\n        tagDepth -= 1;\n      } else if (tagDepth > 0) {\n        console.error('There is an unclosed tag', content);\n        break;\n      }\n    }\n  } while (tagDepth > 0);\n\n  nextCloseNdx += 4;\n\n  if (nextCloseNdx === -1) console.error(\"ERROR: no closing tag! you are missing a '\" + endPattern + \"'\");\n\n  return nextCloseNdx;\n}\n\n// Splits a string into an array where special tags are on their own\n// can optionally only split it up based on a particular tag\nfunction splitContent(content, tag) {\n  var arr = [],\n      openNdx = -1,\n      closeNdx = -1,\n      partial = \"\",\n      startPattern = tag || '<!--#',\n      endPattern = '-->';\n\n  //prime the loop\n  openNdx = content.indexOf(startPattern);\n\n  if (openNdx === -1) return [content];\n\n  while (openNdx > -1) {\n    partial = content.slice(0, openNdx);\n    arr.push(partial);\n    content = content.slice(openNdx);\n\n    // get the closeNdx despite inner open tags\n    // openNdx-><!-- <!-- --> <!-- <!-- --> --> --><-closeNdx\n    var _closeNdx = getIndexOfClosingBrace(content, startPattern, endPattern);\n\n    partial = content.slice(0, _closeNdx);\n    arr.push(partial);\n    content = content.slice(_closeNdx);\n    openNdx = content.indexOf(startPattern);\n\n    // on final pass, push the remainer of the content string\n    if (openNdx === -1) arr.push(content);\n  }\n\n  // Now we have an array of tags, and content\n  return arr;\n}\n\n// ToDo. These should go to a better place, for now only one place was using a\n// magic number\nvar RAW_JSON_NDX = 0;\nvar JSON_PATH_NDX = 1;\nvar FILE_PATH_NDX = 2;\nvar CONTENT_NDX = 3;\n\n// returns the index of the closing tag for a given opening tag\nfunction findIndexOfClosingTag(openTag, closeTag, startNdx, arr) {\n  var endNdx = -1;\n  var openCount = 1;\n\n  for (var i = startNdx + 1; i < arr.length; i++) {\n    var fragment = Array.isArray(arr[i]) ? arr[i][CONTENT_NDX] // [i] contains [rawJson, jsonPath, filePath, content]\n    : arr[i];\n\n    if (fragment.indexOf(openTag) === 0) openCount++;else if (fragment.indexOf(closeTag) === 0) {\n      openCount--;\n      if (openCount === 0) {\n        endNdx = i;\n        break;\n      }\n    }\n  }\n  return endNdx;\n}\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.toSafeJsonString = toSafeJsonString;\nexports.processRawJson = processRawJson;\nexports.appendJsonParentPath = appendJsonParentPath;\nexports.addRawJsonWhereJsonPath = addRawJsonWhereJsonPath;\n\nvar _parsing = __webpack_require__(2);\n\nvar _attributes = __webpack_require__(1);\n\nvar _config = __webpack_require__(0);\n\n// given a jsonObj, we can convert it to a string for our purposes\nfunction toSafeJsonString(jsonObj) {\n  return JSON.stringify(jsonObj).replace(/\\'/g, \"\\\\'\").replace(/\"/g, \"'\");\n}\n\n// Handles the string value inside of rawJson=\"\" attributes\nfunction processRawJson(jsonString) {\n  var jsonData = {};\n\n  if ((typeof jsonString === 'undefined' ? 'undefined' : _typeof(jsonString)) === 'object') jsonString = toSafeJsonString(jsonString);\n\n  try {\n    eval('jsonData = ' + jsonString);\n  } catch (e) {\n    console.error('ERROR: Poorly formatted rawJson string: ' + jsonString + '\\n\\n This must be valid JavaScript.');\n  }\n\n  return jsonData;\n}\n\n// add json paths together\nfunction appendJsonParentPath(content, jsonParentPath) {\n  var fndx = -1,\n      lndx = -1,\n      left = \"\",\n      right = \"\";\n\n  // do nothing if there is no jsonParentPath\n  if (jsonParentPath === '' || jsonParentPath === 'this') return content;\n\n  content = (0, _parsing.splitContent)(content, '<!--#data'); // '' => ['']\n\n  // if we have an array larger than 1, then there is at least 1 insert to be made\n  if (content.length > 1) {\n\n    // process files\n    content = content.map(function (fragment, ndx, arr) {\n      if (fragment.indexOf('<!--#data') === 0) {\n        fndx = fragment.indexOf(_config.jsonPathAttribute + '=\"');\n        if (fndx > -1) {\n          left = fragment.slice(0, fndx + 10);\n          fragment = left + jsonParentPath + '.' + fragment.slice(fndx + 10);\n        } else {\n          console.error(\"ERROR: '<!--#data' tag with no 'jsonPath'\");\n        }\n      }\n      return fragment;\n    });\n  }\n  // re-join content into a string\n  content = content.join(''); // [''] => ''\n  return content;\n}\n\n// splits up content into tags and puts rawJson in (if there isn't already a rawJson)\nfunction addRawJsonWhereJsonPath(content, rawJson, jsonParentPath) {\n  var fndx = -1,\n      lndx = -1,\n      left = \"\",\n      right = \"\";\n\n  // if we have a parent path, then we need to grab a subset of the rawJson\n  if (jsonParentPath && rawJson) {\n    var data = processRawJson(rawJson);\n    rawJson = (0, _parsing.getDataFromJsonPath)(jsonParentPath, data);\n  }\n\n  content = bluntDataTagsInEaches(content);\n\n  content = (0, _parsing.splitContent)(content); // '' => ['']\n\n  // if we have an array larger than 1, then there is at least 1 insert to be made\n  if (content.length > 1) {\n\n    // process files\n    content = content.map(function (fragment, ndx, arr) {\n      if (fragment.indexOf('<!--#') === 0 && (0, _attributes.hasTagAttribute)(_config.jsonPathAttribute, fragment) && !(0, _attributes.hasTagAttribute)(\"rawJson\", fragment)) {\n        fragment = (0, _attributes.addTagAttribute)(\"rawJson\", fragment, rawJson);\n      }\n      return fragment;\n    });\n  }\n  // re-join content into a string\n  content = content.join(''); // [''] => ''\n\n  content = unbluntDataTagsInEaches(content);\n  return content;\n}\n\nfunction bluntDataTagsInEaches(content) {\n  var arr = (0, _parsing.splitContent)(content);\n  var eachLevel = 0;\n\n  content = arr.map(function (fragment, ndx, arr) {\n    if (fragment.indexOf('<!--#each') === 0) eachLevel++;\n    if (fragment.indexOf('<!--#endeach') === 0) eachLevel--;\n    if (fragment.indexOf('<!--#data') === 0 && eachLevel > 0) fragment = fragment.replace('<!--#data', '<!--@#data');\n    return fragment;\n  }).join('');\n\n  if (eachLevel > 0) console.error('Error: Mismatched number of each and endeach tags');\n\n  return content;\n}\n\nfunction unbluntDataTagsInEaches(content) {\n  content = content.replace(/<!--@#data/g, '<!--#data');\n  return content;\n}\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.File = File;\nexports.buildPathFromRelativePath = buildPathFromRelativePath;\nexports.updateRelativePaths = updateRelativePaths;\n\nvar _platform = __webpack_require__(8);\n\nvar _attributes = __webpack_require__(1);\n\nvar _parsing = __webpack_require__(2);\n\nvar _config = __webpack_require__(0);\n\nfunction File(file) {\n  var f = {\n    name: '',\n    path: file.path,\n    content: file.contents.toString('utf8').trim(),\n    processed: false,\n    file: file\n  };\n\n  f.name = _platform.isWin ? file.path.split('\\\\') : file.path.split('/');\n  f.name = f.name[f.name.length - 1];\n\n  return f;\n}\n\n// overcome the difference in *nix/windows pathing\nfunction fixFilePathForOS(path) {\n  return _platform.isWin ? path.replace(/\\//g, '\\\\') : path.replace(/\\\\/g, '/');\n}\n\n// given the current directory and a relative path, build the complete path\n// to the relative path\nfunction buildPathFromRelativePath(cdir, fdir) {\n  var dir,\n      dirChar = _platform.isWin ? '\\\\' : '/';\n\n  dir = cdir.split(dirChar);\n\n  fdir = fixFilePathForOS(fdir);\n  dir.pop();\n\n  fdir.split(dirChar).forEach(function (e) {\n    e === '..' ? dir.pop() : e !== '.' && e !== '' ? dir.push(e) : void 0;\n  });\n  dir = dir.join(dirChar);\n  if (_config.devOptions.printPaths) {\n    console.log(\"********buildPathFromRelativePath********\");\n    console.log(\"cdir  : \", cdir);\n    console.log(\"fdir  : \", fdir);\n    console.log(\"result: \", dir);\n    console.log(\"********end buildPathFromRelativePath********\");\n  }\n  return dir;\n}\n\n// Updates the relative path with the parent's path so it can be resolved on the\n// next turn\nfunction updateRelativePaths(content, cdir) {\n  var dir = \"\";\n  content = (0, _parsing.splitContent)(content);\n\n  content = content.map(function (fragment) {\n    if (fragment.indexOf(_config.insertPattern) === 0 || fragment.indexOf('<!--#wrap') === 0) {\n      dir = (0, _attributes.getTagAttribute)(_config.filePathAttribute, fragment);\n      dir = buildPathFromRelativePath(cdir, dir);\n      fragment = (0, _attributes.setTagAttribute)(_config.filePathAttribute, fragment, dir);\n      fragment = (0, _attributes.changeTagAttributeName)(_config.filePathAttribute, fragment, \"absPath\");\n    }\n    return fragment;\n  });\n\n  content = content.join('');\n  return content;\n}\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _clip = __webpack_require__(6);\n\nvar _clip2 = _interopRequireDefault(_clip);\n\nvar _tags = __webpack_require__(7);\n\nvar _tags2 = _interopRequireDefault(_tags);\n\nvar _config = __webpack_require__(0);\n\nvar _file = __webpack_require__(4);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.exports = {\n  initialize: function initialize(options) {\n    return (0, _config.setOptions)(options);\n  },\n  // puts files into hash maps\n  hashFile: function hashFile(file) {\n    var f = (0, _file.File)(file);\n\n    (0, _clip2.default)(f);\n\n    (0, _config.configureFiles)(f);\n  },\n  // builds string\n  buildFileResult: function buildFileResult(callback) {\n    return _config.pageFiles.map(function (file) {\n      file.content = (0, _tags2.default)(file.content, file.path, _config.options.jsonInput || {});\n\n      // correct any unknown tags that were modified\n      file.content = file.content.replace(/<!--!#/g, '<!--#');\n      file.processed = true;\n\n      if (callback) callback(file);\n\n      return file;\n    });\n  }\n};\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = processClip;\n// <!--#clipbefore -->\n// <!--#clipafter -->\n// <!--#clipbetween -->\n// <!--#endclipbetween -->\n// This runs first, since all of the clipped areas will completely be removed\nfunction processClip(file) {\n  var tmp;\n\n  if (file.content.indexOf('<!--#clipbefore') > -1) {\n\n    file.content = file.content.split(/<!--#clipbefore\\s*-->/).splice(1)[0].split('<!--#clipafter').splice(0, 1)[0];\n  }\n\n  if (file.content.indexOf('<!--#clipbetween') > -1) {\n\n    tmp = file.content.split(/<!--#clipbetween\\s*-->/);\n\n    file.content = tmp[0] + tmp[1].split(/<!--#endclipbetween\\s*-->/)[1];\n  }\n}\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n// all the different tags we are going to process\n\n\nexports.default = processContent;\n\nvar _parsing = __webpack_require__(2);\n\nvar _file = __webpack_require__(4);\n\nvar _attributes = __webpack_require__(1);\n\nvar _json = __webpack_require__(3);\n\nvar _data = __webpack_require__(9);\n\nvar _data2 = _interopRequireDefault(_data);\n\nvar _each = __webpack_require__(10);\n\nvar _each2 = _interopRequireDefault(_each);\n\nvar _if = __webpack_require__(11);\n\nvar _if2 = _interopRequireDefault(_if);\n\nvar _insert = __webpack_require__(12);\n\nvar _insert2 = _interopRequireDefault(_insert);\n\nvar _jsonInsert = __webpack_require__(13);\n\nvar _jsonInsert2 = _interopRequireDefault(_jsonInsert);\n\nvar _wrap = __webpack_require__(14);\n\nvar _wrap2 = _interopRequireDefault(_wrap);\n\nvar _config = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Recursive function that does the major systematic work of htmlincluder\n *\n * 1) split content into an array of tags and non-tags\n * 2) if there are any tags (array.length > 1) loop until the parsing is finished\n *\n * @param  {String} content The text that we are processing the tags of\n * @param  {String} path    The current file path\n * @return {String}         The content, now parsed and with all tags replaces\n */\nfunction processContent(content, path, jsonContext) {\n  var splitArr = [];\n  var itterCount = 0;\n\n  // create a tmp version of content to see if we actually do any work on it\n  var contentBeforeProcessing = content;\n\n  // prime loop: split content into all insertion points\n  splitArr = (0, _parsing.splitContent)(content); // '' => ['']\n\n  // if we have an array larger than 1, then there is at least 1 insert to be made\n  while (splitArr.length > 1) {\n\n    splitArr = processSplitArray(splitArr, path, jsonContext);\n\n    // At this point we should have a mix of strings and arrays\n    // We need to loop through again and process each of the arrays\n\n    // re-join content into a string, and repeat\n    content = splitArr.join(''); // [''] => ''\n\n    // We split the string, so there should have been work. Was there?\n    if (content === contentBeforeProcessing) {\n      console.error('Content was split, but no change was made in it: ' + content);\n      console.error('Something in your tagging may be making it impossible to process correctly');\n      console.error('Returning the content without further processing');\n      return content;\n    }\n\n    // split file into all insertion points\n    splitArr = (0, _parsing.splitContent)(content); // '' => ['']\n\n    // debug features\n    if (_config.devOptions.printIterations) console.log(content);\n\n    if (_config.devOptions.limitIterations) {\n      itterCount++;\n      if (itterCount >= _config.devOptions.limitIterations) break;\n    }\n  }\n\n  if (_config.devOptions.printResult) console.log(content);\n\n  return content;\n}\n\n/**\n * Loops through split content. For each tag, it makes a call back up to\n * processContent in order to take care of any inner tags.\n *\n * Once there are no more inner tags, we look at the tag, and depending on its\n * kind, we run a different tag processor on it.\n *\n * @param  {Array}  splitArr    The array of split up tags\n * @param  {String} path        The file path we are currently using for relative paths\n * @param  {Object} jsonContext The json data consumable by tags in this context\n * @return {Array}              The array, having made one pass to process it\n */\nfunction processSplitArray(splitArr, path, jsonContext) {\n  var tempDirectory = void 0;\n  var pathStack = path;\n  // iterate through content\n  for (var i = 0; i < splitArr.length; i++) {\n    var fragment = splitArr[i];\n\n    if (fragment.indexOf('<!--#') === 0) {\n      // process any tags inside of this tag\n      fragment = '<' + processContent(fragment.substr(0, fragment.length - 1).substr(1), path, jsonContext) + '>';\n\n      //\n      // At this point we can assume that the tag we are working with has no\n      // embedded tags.\n      //\n\n      // See if this has a file path, or absolute file path. If we don't have\n      // an absolute path, then we need to build one.\n      var hasPath = (0, _attributes.hasTagAttribute)(_config.filePathAttribute, fragment);\n      var hasAbsPath = (0, _attributes.hasTagAttribute)(\"absPath\", fragment);\n\n      // get or build paths\n      if (hasPath) tempDirectory = (0, _file.buildPathFromRelativePath)(pathStack, (0, _attributes.getTagAttribute)(_config.filePathAttribute, fragment));else if (hasAbsPath) {\n        tempDirectory = (0, _attributes.getTagAttribute)(\"absPath\", fragment);\n        pathStack = tempDirectory;\n      }\n\n      var curFile = {\n        content: fragment,\n        path: pathStack,\n        tmpPath: tempDirectory\n      };\n\n      // handle loading each particular kind of tag\n      if (fragment.indexOf('<!--#data') === 0) {\n        splitArr[i] = (0, _data2.default)(fragment, jsonContext);\n      } else if (fragment.indexOf('<!--#jsonInsert') === 0) {\n        splitArr[i] = (0, _jsonInsert2.default)(fragment);\n      } else if (fragment.indexOf(_config.insertPattern) === 0) {\n        var fileInfo = (0, _insert2.default)(curFile, jsonContext);\n        splitArr[i] = flattenInsertedContent(fileInfo);\n      } else if (fragment.indexOf('<!--#wrap') === 0) {\n        var _processWraps = (0, _wrap2.default)(curFile, i, splitArr, jsonContext),\n            _processWraps2 = _slicedToArray(_processWraps, 2),\n            openNdx = _processWraps2[0],\n            closeNdx = _processWraps2[1];\n\n        splitArr[openNdx] = flattenInsertedContent(splitArr[openNdx]);\n        splitArr[closeNdx] = flattenInsertedContent(splitArr[closeNdx]);\n      } else if (fragment.indexOf('<!--#if') === 0) {\n        (0, _if2.default)(curFile, i, splitArr, jsonContext);\n      } else if (fragment.indexOf('<!--#each') === 0) {\n        (0, _each2.default)(curFile, i, splitArr, jsonContext);\n        splitArr[i] = flattenEach(splitArr[i], pathStack);\n      } else {\n        console.error('An unidentified tag is being used: ' + fragment);\n        splitArr[i] = fragment.replace('<!--#', '<!--!#');\n      }\n\n      pathStack = path;\n    }\n  }\n\n  return splitArr;\n}\n\n/**\n * The result of each tags produce an array that lumps together the expanded\n * content between the two tags.\n *\n * It does this by running through the array, and if data is needed, it runs\n * it through processContent. Otherwise it simply adds it to a string.\n *\n * @param  {Array}  fragment The collection of content between the each tags\n * @param  {String} path     The current file path\n * @return {String}          Processed content between each\n */\nfunction flattenEach(fragment, path) {\n\n  if (!Array.isArray(fragment)) return fragment;\n\n  var result = '';\n  for (var i = 0; i < fragment.length; i++) {\n    if (Array.isArray(fragment[i])) {\n      var _fragment$i = _slicedToArray(fragment[i], 2),\n          data = _fragment$i[0],\n          content = _fragment$i[1];\n\n      result += processContent(content, path, data);\n    } else result += fragment[i];\n  }\n\n  return result;\n}\n\n/**\n * When an #insert or #wrap/#endwrap parse runs it inserts an array into its\n * spot. Then it will flatten this out\n * @param  {[type]} fileInfo [description]\n * @return {[type]}          [description]\n */\nfunction flattenInsertedContent(fileInfo) {\n  var _fileInfo = _slicedToArray(fileInfo, 4),\n      rawJson = _fileInfo[0],\n      jsonParentPath = _fileInfo[1],\n      tmpPath = _fileInfo[2],\n      content = _fileInfo[3];\n\n  return processContent(content, tmpPath, rawJson);\n}\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar isWin = exports.isWin = /^win/.test(process.platform);\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = processDataTag;\n\nvar _attributes = __webpack_require__(1);\n\nvar _json = __webpack_require__(3);\n\nvar _parsing = __webpack_require__(2);\n\nvar _config = __webpack_require__(0);\n\n// <!--#data jsonPath=\"\" default=\"\" -->\nfunction processDataTag(tag, jsonContext) {\n  var jsonPath = \"\",\n      rawJson = \"\",\n      defaultValue = \"\",\n      jsonData = \"\";\n\n  jsonPath = (0, _attributes.getTagAttribute)(_config.jsonPathAttribute, tag);\n\n  if ((0, _attributes.hasTagAttribute)(\"default\", tag)) defaultValue = (0, _attributes.getTagAttribute)('default', tag);\n\n  if ((0, _attributes.hasTagAttribute)('rawJson', tag)) {\n    rawJson = (0, _attributes.getTagAttribute)('rawJson', tag);\n    rawJson = (0, _json.processRawJson)(rawJson);\n  } else if (jsonContext) rawJson = (0, _json.processRawJson)(jsonContext);\n\n  jsonData = (0, _parsing.getDataFromJsonPath)(jsonPath, rawJson);\n  var result = jsonData || defaultValue;\n\n  return typeof result === 'string' ? result : JSON.stringify(result).replace(/\"/g, \"'\");\n}\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = processEach;\n\nvar _attributes = __webpack_require__(1);\n\nvar _json = __webpack_require__(3);\n\nvar _parsing = __webpack_require__(2);\n\nvar _config = __webpack_require__(0);\n\n// <!--#each count=\"\" jsonPath=\"\" rawJson=\"\" -->\n// <!--#endeach -->\nfunction processEach(file, ndx, arr, jsonContext) {\n  var endNdx = -1,\n      startNdx = ndx + 1,\n      content = arr[ndx],\n      jsonPath = '',\n      rawJson = '',\n      jsonData = '',\n      count = false;\n\n  // find the closing tag for this each\n  endNdx = (0, _parsing.findIndexOfClosingTag)('<!--#each', '<!--#endeach', ndx, arr);\n\n  // If we have no closing tag, then this is an error\n  if (endNdx === -1) {\n    console.error(\"ERROR: in file \" + file.path + \": <!--#each --> with no <!--#endeach -->\");\n    return;\n  }\n\n  // Maybe don't allow empty each tags\n  if (endNdx === ndx - 1) console.warn(\"WARNING: in file \" + file.path + \": <!--#each --> with no content\");\n\n  // look up the jsonPath used for this\n  if ((0, _attributes.hasTagAttribute)(_config.jsonPathAttribute, content)) jsonPath = (0, _attributes.getTagAttribute)(_config.jsonPathAttribute, content);\n\n  // see if there is rawJson on this, or get the jsonContext intead\n  if ((0, _attributes.hasTagAttribute)('rawJson', content)) {\n    rawJson = (0, _attributes.getTagAttribute)('rawJson', content);\n    rawJson = (0, _json.processRawJson)(rawJson);\n  } else if (jsonContext) rawJson = (0, _json.processRawJson)(jsonContext);\n\n  // if we have a path to look up data with, then use it\n  if (jsonPath) jsonData = (0, _parsing.getDataFromJsonPath)(jsonPath, rawJson);\n\n  // see if there is a hard coded loop count\n  if ((0, _attributes.hasTagAttribute)('count', content)) count = parseInt((0, _attributes.getTagAttribute)('count', content), 10);\n\n  // Check if the jsonData is an array, if it is we should use it for the count\n  if (Array.isArray(jsonData)) {\n    // if we don't have a count, set it to length,\n    // else we will constrain how many items we will loop on\n    if (!count) count = jsonData.length;else if (count > jsonData.length) {\n      console.warn(\"WARNING: in file \" + file.path + \": <!--#each --> with count attribute higher than array input's length. Changing to length of array\");\n      count = jsonData.length;\n    }\n  }\n\n  // If there is no count and no jsonPath, then there is probably something forgotten\n  if (!count && !jsonPath) {\n    console.error(\"ERROR: in file \" + file.path + \": <!--#each --> with no count attribute, and no array as json object.\");\n    return;\n  }\n\n  ///\n  /// At this point we have the start and end indexes, and the data we are using\n  /// to render the content between the statements.\n  ///\n  /// The strategy used is to get this content, and then to duplicate it as many\n  /// times as the count. The content is all now within an array that replaces\n  /// everything from the current index to the index of the ending each tag.\n  ///\n\n  // clear end tag\n  arr[ndx] = '';\n  arr[endNdx] = '';\n\n  var middleMaster = arr.splice(startNdx, endNdx - startNdx).join('');\n\n  content = [];\n\n  // create all the duplicates of the data with the proper inserted data\n  for (var i = 0; i < count; i++) {\n    if (jsonData) content.push([jsonData[i], middleMaster]);else content.push(middleMaster);\n  } // cut out original each, and replace with array\n  arr.splice(ndx, 2, content);\n}\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = processIf;\n\nvar _attributes = __webpack_require__(1);\n\nvar _json = __webpack_require__(3);\n\nvar _parsing = __webpack_require__(2);\n\nvar _config = __webpack_require__(0);\n\n// <!--#if jsonPath=\"\" rawJson=\"\" -->\n// <!--#endif -->\nfunction processIf(file, ndx, arr, jsonContext) {\n  var endNdx = -1,\n      content = arr[ndx],\n      rawJson = \"\",\n      jsonPath = \"\",\n      jsonData = void 0;\n\n  if ((0, _attributes.hasTagAttribute)(_config.jsonPathAttribute, content)) jsonPath = (0, _attributes.getTagAttribute)(_config.jsonPathAttribute, content);\n\n  if ((0, _attributes.hasTagAttribute)('rawJson', content)) {\n    rawJson = (0, _attributes.getTagAttribute)('rawJson', content);\n    rawJson = (0, _json.processRawJson)(rawJson);\n  } else if (jsonContext) rawJson = (0, _json.processRawJson)(jsonContext);\n\n  jsonData = (0, _parsing.getDataFromJsonPath)(jsonPath, rawJson);\n\n  // clear if statement\n  arr[ndx] = \"\";\n\n  endNdx = (0, _parsing.findIndexOfClosingTag)('<!--#if', '<!--#endif', ndx, arr);\n\n  // If we have no closing tag, then this is an error\n  if (endNdx === -1) {\n    console.error(\"ERROR: in file \" + file.path + \": <!--#if . . . --> with no <!--#endif . . . -->\");\n    return;\n  }\n\n  // clear endif statement\n  arr[endNdx] = \"\";\n\n  // If there is no jsonPath we have no way to check the data ...\n  if (!jsonPath) {\n    console.error(\"ERROR: in file \" + file.path + \": <!--#if --> with no jsonPath\");\n    return;\n  }\n\n  // if undefined jsonData or false, then we eliminate the section\n  if (typeof jsonData === 'undefined' || jsonData == false) arr.splice(ndx, endNdx - ndx);\n}\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = processInsert;\n\nvar _attributes = __webpack_require__(1);\n\nvar _json = __webpack_require__(3);\n\nvar _file = __webpack_require__(4);\n\nvar _config = __webpack_require__(0);\n\n// <!--#insert path=\"\" -->\nfunction processInsert(file, jsonContext) {\n  var filename = \"\";\n  var content = file.content;\n\n  var rawJson = (0, _attributes.hasTagAttribute)('rawJson', content) ? (0, _attributes.getTagAttribute)('rawJson', content) : \"\";\n\n  var jsonParentPath = (0, _attributes.hasTagAttribute)(_config.jsonPathAttribute, content) ? (0, _attributes.getTagAttribute)(_config.jsonPathAttribute, content) : \"\";\n\n  if ((0, _attributes.hasTagAttribute)(_config.filePathAttribute, content)) {\n    filename = (0, _attributes.getTagAttribute)(_config.filePathAttribute, content);\n    filename = (0, _file.buildPathFromRelativePath)(file.path, filename);\n  } else if ((0, _attributes.hasTagAttribute)('absPath', content)) filename = (0, _attributes.getTagAttribute)(\"absPath\", content);\n\n  if (_config.insertFiles[filename]) content = _config.insertFiles[filename].content;else {\n    console.error(\"ERROR: in file '\" + file.path + \"': insert file `\" + filename + \"` does not exist\");\n    return \"\";\n  }\n\n  return [rawJson, jsonParentPath, file.tmpPath, content];\n}\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = processJsonInsert;\n\nvar _attributes = __webpack_require__(1);\n\nvar _parsing = __webpack_require__(2);\n\nvar _config = __webpack_require__(0);\n\n// <!--#jsonInsert jsonPath=\"\" default=\"\" -->\nfunction processJsonInsert(tag) {\n  var defaultValue = (0, _attributes.hasTagAttribute)(\"default\", tag) ? (0, _attributes.getTagAttribute)('default', tag) : \"\";\n\n  var jsonPath = (0, _attributes.getTagAttribute)(_config.jsonPathAttribute, tag);\n  var jsonData = (0, _parsing.getDataFromJsonPath)(jsonPath);\n\n  if (jsonData || defaultValue) return jsonData || defaultValue;else {\n    console.warn(\"ERROR: jsonPath `\" + jsonPath + \"` is undefined, and no default value\");\n    return \"\";\n  }\n}\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = processWraps;\n\nvar _attributes = __webpack_require__(1);\n\nvar _config = __webpack_require__(0);\n\nvar _json = __webpack_require__(3);\n\nvar _file = __webpack_require__(4);\n\nvar _parsing = __webpack_require__(2);\n\n// <!--#wrap path=\"\" jsonPath=\"\" rawJson=\"\" -->\n// <!--#middle -->\n// <!--#endwrap -->\nfunction processWraps(file, ndx, arr, jsonContext) {\n  var endNdx = -1,\n      fpath = \"\",\n      content = arr[ndx],\n      filename = \"\",\n      rawJson = \"\",\n      jsonParentPath = \"\",\n      pathPattern = 'path=\"',\n      absPathPattern = 'absPath=\"',\n      pattern = content.indexOf(pathPattern) > -1 ? pathPattern : absPathPattern;\n\n  // see if we are loading a json path\n  if ((0, _attributes.hasTagAttribute)(_config.jsonPathAttribute, content)) jsonParentPath = (0, _attributes.getTagAttribute)(_config.jsonPathAttribute, content);\n\n  // see if we have raw json to load from\n  if ((0, _attributes.hasTagAttribute)('rawJson', content)) rawJson = (0, _attributes.getTagAttribute)('rawJson', content);\n\n  // get filepath (either relative or absolute)\n  filename = pattern === pathPattern ? (0, _attributes.getTagAttribute)(_config.filePathAttribute, arr[ndx]) : (0, _attributes.getTagAttribute)(\"absPath\", arr[ndx]);\n\n  // build filepath if its relative\n  fpath = pattern === pathPattern ? (0, _file.buildPathFromRelativePath)(file.path, filename) : filename;\n\n  // find closing tag\n  endNdx = (0, _parsing.findIndexOfClosingTag)('<!--#wrap', '<!--#endwrap', ndx, arr);\n\n  // If we have no closing tag, then this is an error\n  if (endNdx === -1) {\n    console.error(\"ERROR: in file \" + file.path + \": <!--#wrap . . . --> with no <!--#endwrap . . . -->\");\n    return \"\";\n  }\n\n  // Get the wrap file and split it in the middle\n  if (_config.wrapFiles[fpath]) {\n    content = _config.wrapFiles[fpath].content.split(/<!--#middle\\s*-->/);\n    if (content.length !== 2) {\n      console.error(\"ERROR: in file \" + file.path + \": wrap file has no <!--#middle--> or more than one <!--#middle--> tags\");\n      return \"\";\n    }\n  } else {\n    console.error(\"ERROR: in file \" + file.path + \": no wrapFile by the name `\" + filename + \"`\");\n    return \"\";\n  }\n\n  arr[ndx] = [rawJson, jsonParentPath, file.tmpPath, content[0]];\n  arr[endNdx] = [rawJson, jsonParentPath, file.tmpPath, content[1]];\n  return [ndx, endNdx];\n}\n\n/***/ })\n/******/ ])));\n\n\n// WEBPACK FOOTER //\n// htmlincluder.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f9718fd9affc52bb7c24","export const wrapFiles = {};\nexport const insertFiles = {};\nexport const pageFiles = [];\n\nexport let options = {};\nexport let devOptions = {};\nexport let insertPattern;\nexport let filePathAttribute;\nexport let jsonPathAttribute;\n\nexport const configureFiles = file => {\n  if(file.name[0] === '_')\n    wrapFiles[file.path] = file;\n  else if(file.name[0] === '-')\n    insertFiles[file.path] = file;\n  else\n    pageFiles.push(file);\n}\n\n// @options = (optional) options for configuring htmlIncluder\n// options.jsonInput         = A json object used to populate data in files\n// options.insertPattern     = The test looked for in order to insert files\n//          (this is so ssi includes can be used instead)\n// options.filePathAttribute = the name used for the file pathing for #insert\n//          and #wrap (default= 'path')\n// options.jsonPathAttribute = the name used for the file pathing for #insert\n//          , #wrap, #data, #jsonInsert (default= 'jsonPath')\n//\n//\n// options.dev.limitIterations = the number of times processFileWithJsonInput will loop\n// options.dev.printIterations = console log each processFileWithJsonInput loop\n// options.dev.printResult = console logs the final output\n// options.dev.printPaths = console logs the output of buildPathFromRelativePath\nexport const setOptions = ops => {\n  devOptions = ops.dev || {};\n  options = ops;\n\n  //set text value for insert tags, or default\n  insertPattern = (options.insertPattern)\n    ? '<!--#' + options.insertPattern\n    : '<!--#insert';\n\n  filePathAttribute = (options.filePathAttribute)\n    ? options.filePathAttribute\n    : 'path';\n\n  jsonPathAttribute = (options.jsonPathAttribute)\n    ? options.jsonPathAttribute\n    : 'jsonPath';\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/config.js","// does a tag have an attribute? (attributeName=\"value\")\nexport function hasTagAttribute(attr, content) {\n  // strip out inner tags\n  // check attribute existence\n  return content.indexOf(attr + '=\"') > -1;\n}\n\n// get the value of an attribute (attributeName=\"value\")\nexport function getTagAttribute(attr, content) {\n  var fndx = -1,\n      lndx = -1;\n\n  fndx = content.indexOf(attr + '=\"');\n  if(fndx === -1) {\n    console.warn(\"Warning: no tag of name `\" + attr + \"` found in the following content: `\" + content + \"`\")\n    return \"\";\n  }\n\n  content = content.slice(fndx + attr.length + 2);\n  lndx = content.indexOf('\"');\n  content = content.slice(0, lndx);\n  return content;\n}\n\n// set the value of an attribute (attributeName=\"value\")\nexport function setTagAttribute(attr, content, value) {\n  var fndx = -1,\n      lndx = -1,\n      left = \"\",\n      right = \"\";\n\n  fndx = content.indexOf(attr + '=\"');\n  left = content.slice(0, fndx + attr.length + 2);\n  content = content.slice(fndx + attr.length + 2);\n  lndx = content.indexOf('\"');\n  right = content.slice(lndx);\n  content = left + value + right;\n  return content;\n}\n\n// rename one attribute name to another (attributeName=\"value\")\nexport function changeTagAttributeName(attr, content, newAttr) {\n  var fndx = -1,\n      lndx = -1,\n      left = \"\",\n      right = \"\";\n\n  fndx = content.indexOf(attr + '=\"');\n  left = content.slice(0, fndx);\n  right = content.slice(fndx + attr.length);\n  return left + newAttr + right;\n}\n\n// removes an attribute from a tag along with its value (attributeName=\"value\")\nexport function removeTagAttribute(attr, content) {\n  var fndx = -1,\n      lndx = -1,\n      left = \"\",\n      right = \"\",\n      middle = content;\n\n  if(hasTagAttribute(attr, middle)) {\n    fndx = middle.indexOf(attr + '=\"');\n    left = middle.slice(0, fndx);\n    right = middle.slice(fndx + attr.length + 2);\n    // really naive for now - just look for another '\"'\n    lndx = right.indexOf('\"');\n    if(lndx === -1) {\n      console.error('ERROR: No close `\"` in tag ' + content)\n      return content;\n    }\n    else {\n      right = right.slice(lndx + 1);\n      middle = \"\";\n    }\n  }\n  return left + middle + right;\n}\n\n// adds an attribute from a tag along with a value (attributeName=\"value\")\nexport function addTagAttribute(attr, content, value) {\n  var fndx = -1,\n      lndx = -1,\n      left = \"\",\n      right = \"\",\n      middle = content;\n\n  lndx = middle.indexOf(\" \");\n  if(lndx > -1) {\n    left = middle.slice(0, lndx);\n    right = middle.slice(lndx);\n    middle = ` ${attr}=\"${value}\"`;\n  }\n\n  return left + middle + right;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/attributes/index.js","import { toSafeJsonString } from '../json';\nimport { options } from '../config';\n\n// given a jsonObject and a path, return the data pointed at\nexport function getDataFromJsonPath(jsonPath, jsonObj) {\n  var json = jsonObj || options.jsonInput;\n  var result;\n\n  if(jsonPath === '*') return options.jsonInput;\n  if(jsonPath === 'this') return json;\n  result = jsonPath.split('.').reduce((acc, cur) => acc ? acc[cur] : '', json)\n\n  if(Array.isArray(result));\n  else if(typeof(result) === 'object')\n    result = toSafeJsonString(result);\n\n  return result;\n}\n\n// Given some content (starting with a tag) find the index after the end tag\nexport function getIndexOfClosingBrace(content, startPattern, endPattern) {\n  let tagDepth = 0;// when this gets to 0 we are done\n  let tmpContent = content.substr(1);\n\n  // prime loop by finding next start tag\n  let nextCloseNdx = tmpContent.indexOf(endPattern);\n  let nextOpenNdx = tmpContent.indexOf(startPattern);\n\n  if(nextCloseNdx ===  -1)\n    console.error('No Close tag');\n\n  // if there is a nextCloseNdx, but no openNdx, return the end of the tag.\n  if(nextOpenNdx === -1 || nextOpenNdx > nextCloseNdx)\n    return nextCloseNdx + 4;\n\n  // Now we know that we have an inner tag ... or should if the syntax is correct\n\n  // we found an open tag, so we need a close tag. Set depth to 1\n  tagDepth = 1;\n\n  // add 1 so we will search passed the tag\n  nextOpenNdx += 1;\n  nextCloseNdx += 1;\n\n  // while current tag is not closed...\n  do {\n    let tmpOpen, tmpClosed;\n\n    // start tag is before close tag, then\n    // we can look to see if there is yet another tag nested between\n    if(nextOpenNdx > -1 && nextOpenNdx < nextCloseNdx) {\n      tmpOpen = tmpContent.substr(nextOpenNdx).indexOf(startPattern);\n      // see if we found something, and add this new index to our accumulator\n      if(tmpOpen > -1) {\n        // add 1 because we need next search to be beyond this tag\n        nextOpenNdx += tmpOpen + 2;\n        tagDepth += 1;\n      }\n      else\n        nextOpenNdx = -1;\n    }\n    else { // current close tag is before start tag\n      tmpClosed = tmpContent.substr(nextCloseNdx).indexOf(endPattern);\n      // see if we found something, and add this new index to our accumulator\n      if(tmpClosed > -1) {\n        // add 1 because we need next search to be beyond this tag\n        nextCloseNdx += tmpClosed + 2;\n        tagDepth -= 1;\n      }\n      else if(tagDepth > 0) {\n        console.error('There is an unclosed tag', content);\n        break;\n      }\n    }\n  } while(tagDepth > 0)\n\n  nextCloseNdx += 4;\n\n  if(nextCloseNdx === -1)\n    console.error(\"ERROR: no closing tag! you are missing a '\" + endPattern + \"'\");\n\n  return nextCloseNdx;\n}\n\n// Splits a string into an array where special tags are on their own\n// can optionally only split it up based on a particular tag\nexport function splitContent(content, tag) {\n  let arr = [],\n      openNdx = -1,\n      closeNdx = -1,\n      partial = \"\",\n      startPattern = tag || '<!--#',\n      endPattern = '-->';\n\n  //prime the loop\n  openNdx = content.indexOf(startPattern);\n\n  if(openNdx === -1)\n    return [content];\n\n  while(openNdx > -1) {\n    partial = content.slice(0, openNdx);\n    arr.push(partial);\n    content = content.slice(openNdx);\n\n    // get the closeNdx despite inner open tags\n    // openNdx-><!-- <!-- --> <!-- <!-- --> --> --><-closeNdx\n    let closeNdx = getIndexOfClosingBrace(content, startPattern, endPattern);\n\n    partial = content.slice(0, closeNdx);\n    arr.push(partial);\n    content = content.slice(closeNdx);\n    openNdx = content.indexOf(startPattern);\n\n    // on final pass, push the remainer of the content string\n    if(openNdx === -1)\n      arr.push(content);\n  }\n\n  // Now we have an array of tags, and content\n  return arr;\n}\n\n// ToDo. These should go to a better place, for now only one place was using a\n// magic number\nconst RAW_JSON_NDX  = 0;\nconst JSON_PATH_NDX = 1;\nconst FILE_PATH_NDX = 2;\nconst CONTENT_NDX   = 3;\n\n// returns the index of the closing tag for a given opening tag\nexport function findIndexOfClosingTag(openTag, closeTag, startNdx, arr) {\n  var endNdx = -1;\n  var openCount = 1;\n\n  for(var i = startNdx + 1; i < arr.length; i++) {\n    let fragment = (Array.isArray(arr[i]))\n      ? arr[i][CONTENT_NDX] // [i] contains [rawJson, jsonPath, filePath, content]\n      : arr[i];\n\n    if(fragment.indexOf(openTag) === 0)\n      openCount++;\n    else if(fragment.indexOf(closeTag) === 0) {\n      openCount--;\n      if(openCount === 0) {\n        endNdx = i;\n        break;\n      }\n    }\n  }\n  return endNdx;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/util/parsing.js","import { splitContent, getDataFromJsonPath } from '../util/parsing';\nimport { hasTagAttribute, addTagAttribute } from '../attributes';\nimport { jsonPathAttribute } from '../config';\n\n// given a jsonObj, we can convert it to a string for our purposes\nexport function toSafeJsonString(jsonObj) {\n  return JSON.stringify(jsonObj).replace(/\\'/g, \"\\\\'\").replace(/\"/g, \"'\")\n}\n\n// Handles the string value inside of rawJson=\"\" attributes\nexport function processRawJson(jsonString) {\n  var jsonData = {};\n\n  if(typeof(jsonString) === 'object')\n    jsonString = toSafeJsonString(jsonString);\n\n  try {\n    eval('jsonData = ' + jsonString);\n  }\n  catch(e) {\n    console.error('ERROR: Poorly formatted rawJson string: ' + jsonString + '\\n\\n This must be valid JavaScript.');\n  }\n\n  return jsonData;\n}\n\n// add json paths together\nexport function appendJsonParentPath(content, jsonParentPath) {\n  var fndx = -1,\n      lndx = -1,\n      left = \"\",\n      right = \"\";\n\n  // do nothing if there is no jsonParentPath\n  if(jsonParentPath === '' || jsonParentPath === 'this')\n    return content;\n\n  content = splitContent(content, '<!--#data'); // '' => ['']\n\n  // if we have an array larger than 1, then there is at least 1 insert to be made\n  if(content.length > 1) {\n\n    // process files\n    content = content.map(function(fragment, ndx, arr) {\n        if(fragment.indexOf('<!--#data') === 0) {\n          fndx = fragment.indexOf(`${jsonPathAttribute}=\"`)\n          if(fndx > -1) {\n            left = fragment.slice(0, fndx + 10);\n            fragment = left + jsonParentPath + '.' + fragment.slice(fndx + 10);\n          }\n          else {\n            console.error(\"ERROR: '<!--#data' tag with no 'jsonPath'\");\n          }\n        }\n        return fragment;\n      })\n\n  }\n  // re-join content into a string\n  content = content.join('') // [''] => ''\n  return content;\n}\n\n// splits up content into tags and puts rawJson in (if there isn't already a rawJson)\nexport function addRawJsonWhereJsonPath(content, rawJson, jsonParentPath) {\n  var fndx = -1,\n      lndx = -1,\n      left = \"\",\n      right = \"\";\n\n  // if we have a parent path, then we need to grab a subset of the rawJson\n  if(jsonParentPath && rawJson) {\n    let data = processRawJson(rawJson);\n    rawJson = getDataFromJsonPath(jsonParentPath, data);\n  }\n\n  content = bluntDataTagsInEaches(content);\n\n  content = splitContent(content); // '' => ['']\n\n  // if we have an array larger than 1, then there is at least 1 insert to be made\n  if(content.length > 1) {\n\n    // process files\n    content = content.map(function(fragment, ndx, arr) {\n        if(fragment.indexOf('<!--#') === 0 &&\n           hasTagAttribute(jsonPathAttribute, fragment) &&\n           !hasTagAttribute(\"rawJson\", fragment)\n          ) {\n          fragment = addTagAttribute(\"rawJson\", fragment, rawJson);\n        }\n        return fragment;\n      })\n\n  }\n  // re-join content into a string\n  content = content.join(''); // [''] => ''\n\n  content = unbluntDataTagsInEaches(content);\n  return content;\n}\n\nfunction bluntDataTagsInEaches(content) {\n  let arr = splitContent(content);\n  let eachLevel = 0;\n\n  content = arr.map((fragment, ndx, arr) => {\n    if(fragment.indexOf('<!--#each') === 0) eachLevel++;\n    if(fragment.indexOf('<!--#endeach') === 0) eachLevel--;\n    if(fragment.indexOf('<!--#data') === 0 && eachLevel > 0)\n      fragment = fragment.replace('<!--#data', '<!--@#data');\n    return fragment;\n  }).join('');\n\n  if(eachLevel > 0)\n    console.error('Error: Mismatched number of each and endeach tags');\n\n  return content;\n}\n\nfunction unbluntDataTagsInEaches(content) {\n  content = content.replace(/<!--@#data/g, '<!--#data');\n  return content;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/json/index.js","import { isWin } from './platform';\nimport { getTagAttribute, setTagAttribute, changeTagAttributeName } from '../attributes';\nimport { splitContent } from './parsing';\nimport { devOptions, insertPattern, filePathAttribute } from '../config';\n\nexport function File(file) {\n  var f = {\n    name : '',\n    path : file.path,\n    content : file.contents.toString('utf8').trim(),\n    processed : false,\n    file : file\n  };\n\n  f.name = (isWin) ? file.path.split('\\\\') : file.path.split('/');\n  f.name = f.name[f.name.length-1];\n\n  return f;\n}\n\n// overcome the difference in *nix/windows pathing\nfunction fixFilePathForOS(path) {\n  return (isWin) ? path.replace(/\\//g, '\\\\') : path.replace(/\\\\/g, '/');\n}\n\n// given the current directory and a relative path, build the complete path\n// to the relative path\nexport function buildPathFromRelativePath(cdir, fdir) {\n  var dir,\n      dirChar = (isWin) ? '\\\\' : '/';\n\n  dir = cdir.split(dirChar);\n\n  fdir = fixFilePathForOS(fdir);\n  dir.pop();\n\n  fdir.split(dirChar)\n    .forEach(function(e) {\n      (e === '..') ? dir.pop() : (e !== '.' && e !== '') ? dir.push(e) : void 0;\n    });\n  dir = dir.join(dirChar);\n  if(devOptions.printPaths) {\n    console.log(\"********buildPathFromRelativePath********\")\n    console.log(\"cdir  : \", cdir)\n    console.log(\"fdir  : \", fdir)\n    console.log(\"result: \", dir)\n    console.log(\"********end buildPathFromRelativePath********\")\n  }\n  return dir;\n}\n\n// Updates the relative path with the parent's path so it can be resolved on the\n// next turn\nexport function updateRelativePaths(content, cdir) {\n  var dir = \"\";\n  content = splitContent(content);\n\n  content = content.map(function(fragment) {\n    if(fragment.indexOf(insertPattern)  === 0 ||\n       fragment.indexOf('<!--#wrap')    === 0) {\n      dir = getTagAttribute(filePathAttribute, fragment);\n      dir = buildPathFromRelativePath(cdir, dir);\n      fragment = setTagAttribute(filePathAttribute, fragment, dir);\n      fragment = changeTagAttributeName(filePathAttribute, fragment, \"absPath\");\n    }\n    return fragment;\n  })\n\n  content = content.join('');\n  return content;\n}\n\n\n// WEBPACK FOOTER //\n// ./src/util/file.js","import processClip from './tags/clip';\nimport processContent from './tags';\nimport { configureFiles, setOptions, pageFiles, options } from './config';\nimport { File } from './util/file';\n\nmodule.exports = {\n  initialize : options => setOptions(options),\n  // puts files into hash maps\n  hashFile : file => {\n    const f = File(file);\n\n    processClip(f);\n\n    configureFiles(f);\n  },\n  // builds string\n  buildFileResult : callback => pageFiles.map(file => {\n    file.content = processContent(file.content, file.path, options.jsonInput || {});\n\n    // correct any unknown tags that were modified\n    file.content = file.content.replace(/<!--!#/g, '<!--#');\n    file.processed = true;\n\n    if(callback)\n      callback(file);\n\n    return file;\n  }),\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","// <!--#clipbefore -->\n// <!--#clipafter -->\n// <!--#clipbetween -->\n// <!--#endclipbetween -->\n// This runs first, since all of the clipped areas will completely be removed\nexport default function processClip(file) {\n  var tmp;\n\n  if(file.content.indexOf('<!--#clipbefore') > -1) {\n\n    file.content = file.content\n            .split(/<!--#clipbefore\\s*-->/)\n            .splice(1)[0]\n            .split('<!--#clipafter')\n            .splice(0,1)[0];\n  }\n\n  if(file.content.indexOf('<!--#clipbetween') > -1) {\n\n    tmp = file.content\n        .split(/<!--#clipbetween\\s*-->/);\n\n    file.content = tmp[0] + tmp[1].split(/<!--#endclipbetween\\s*-->/)[1];\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/tags/clip.js","import { splitContent } from '../util/parsing';\nimport { buildPathFromRelativePath, updateRelativePaths } from '../util/file';\nimport { hasTagAttribute, getTagAttribute } from '../attributes';\nimport { addRawJsonWhereJsonPath, appendJsonParentPath } from '../json';\n\n// all the different tags we are going to process\nimport processDataTag     from './data';\nimport processEach        from './each';\nimport processIf          from './if';\nimport processInsert      from './insert';\nimport processJsonInsert  from './jsonInsert';\nimport processWraps       from './wrap';\n\nimport {\n  options,\n  devOptions,\n  insertPattern,\n  filePathAttribute,\n} from '../config';\n\n/**\n * Recursive function that does the major systematic work of htmlincluder\n *\n * 1) split content into an array of tags and non-tags\n * 2) if there are any tags (array.length > 1) loop until the parsing is finished\n *\n * @param  {String} content The text that we are processing the tags of\n * @param  {String} path    The current file path\n * @return {String}         The content, now parsed and with all tags replaces\n */\nexport default function processContent(content, path, jsonContext) {\n  let splitArr = [];\n  let itterCount = 0;\n\n  // create a tmp version of content to see if we actually do any work on it\n  let contentBeforeProcessing = content;\n\n  // prime loop: split content into all insertion points\n  splitArr = splitContent(content); // '' => ['']\n\n  // if we have an array larger than 1, then there is at least 1 insert to be made\n  while(splitArr.length > 1) {\n\n    splitArr = processSplitArray(splitArr, path, jsonContext);\n\n    // At this point we should have a mix of strings and arrays\n    // We need to loop through again and process each of the arrays\n\n    // re-join content into a string, and repeat\n    content = splitArr.join(''); // [''] => ''\n\n    // We split the string, so there should have been work. Was there?\n    if(content === contentBeforeProcessing) {\n      console.error('Content was split, but no change was made in it: ' + content);\n      console.error('Something in your tagging may be making it impossible to process correctly')\n      console.error('Returning the content without further processing')\n      return content;\n    }\n\n    // split file into all insertion points\n    splitArr = splitContent(content); // '' => ['']\n\n    // debug features\n    if(devOptions.printIterations)\n      console.log(content);\n\n    if(devOptions.limitIterations) {\n      itterCount++;\n      if(itterCount >= devOptions.limitIterations)\n        break;\n    }\n  }\n\n  if(devOptions.printResult)\n    console.log(content);\n\n  return content;\n}\n\n/**\n * Loops through split content. For each tag, it makes a call back up to\n * processContent in order to take care of any inner tags.\n *\n * Once there are no more inner tags, we look at the tag, and depending on its\n * kind, we run a different tag processor on it.\n *\n * @param  {Array}  splitArr    The array of split up tags\n * @param  {String} path        The file path we are currently using for relative paths\n * @param  {Object} jsonContext The json data consumable by tags in this context\n * @return {Array}              The array, having made one pass to process it\n */\nfunction processSplitArray(splitArr, path, jsonContext) {\n  let tempDirectory;\n  let pathStack = path;\n  // iterate through content\n  for(let i = 0; i < splitArr.length; i++) {\n    let fragment = splitArr[i];\n\n    if(fragment.indexOf('<!--#') === 0) {\n      // process any tags inside of this tag\n      fragment = '<' + processContent(fragment.substr(0, fragment.length - 1).substr(1), path, jsonContext) + '>';\n\n      //\n      // At this point we can assume that the tag we are working with has no\n      // embedded tags.\n      //\n\n      // See if this has a file path, or absolute file path. If we don't have\n      // an absolute path, then we need to build one.\n      let hasPath = hasTagAttribute(filePathAttribute, fragment);\n      let hasAbsPath = hasTagAttribute(\"absPath\", fragment);\n\n      // get or build paths\n      if(hasPath)\n        tempDirectory = buildPathFromRelativePath(pathStack, getTagAttribute(filePathAttribute, fragment));\n      else if(hasAbsPath) {\n        tempDirectory = getTagAttribute(\"absPath\", fragment);\n        pathStack = tempDirectory;\n      }\n\n      let curFile = {\n        content: fragment,\n        path: pathStack,\n        tmpPath: tempDirectory,\n      };\n\n      // handle loading each particular kind of tag\n      if(fragment.indexOf('<!--#data') === 0) {\n        splitArr[i] = processDataTag(fragment, jsonContext);\n      }\n      else if(fragment.indexOf('<!--#jsonInsert') === 0) {\n        splitArr[i] = processJsonInsert(fragment);\n      }\n      else if(fragment.indexOf(insertPattern) === 0) {\n        const fileInfo = processInsert(curFile, jsonContext);\n        splitArr[i] = flattenInsertedContent(fileInfo);\n      }\n      else if(fragment.indexOf('<!--#wrap') === 0) {\n        const [openNdx, closeNdx] = processWraps(curFile, i, splitArr, jsonContext);\n        splitArr[openNdx] = flattenInsertedContent(splitArr[openNdx]);\n        splitArr[closeNdx] = flattenInsertedContent(splitArr[closeNdx]);\n      }\n      else if(fragment.indexOf('<!--#if') === 0) {\n        processIf(curFile, i, splitArr, jsonContext)\n      }\n      else if(fragment.indexOf('<!--#each') === 0) {\n        processEach(curFile, i, splitArr, jsonContext);\n        splitArr[i] = flattenEach(splitArr[i], pathStack);\n      }\n      else {\n        console.error('An unidentified tag is being used: ' + fragment);\n        splitArr[i] = fragment.replace('<!--#', '<!--!#');\n      }\n\n      pathStack = path;\n    }\n  }\n\n  return splitArr;\n}\n\n/**\n * The result of each tags produce an array that lumps together the expanded\n * content between the two tags.\n *\n * It does this by running through the array, and if data is needed, it runs\n * it through processContent. Otherwise it simply adds it to a string.\n *\n * @param  {Array}  fragment The collection of content between the each tags\n * @param  {String} path     The current file path\n * @return {String}          Processed content between each\n */\nfunction flattenEach(fragment, path) {\n\n  if(!Array.isArray(fragment))\n    return fragment;\n\n  let result = '';\n  for(let i = 0; i < fragment.length; i++) {\n    if(Array.isArray(fragment[i])) {\n      const [ data, content ] = fragment[i];\n      result += processContent(content, path, data);\n    }\n    else\n      result += fragment[i];\n  }\n\n  return result;\n}\n\n/**\n * When an #insert or #wrap/#endwrap parse runs it inserts an array into its\n * spot. Then it will flatten this out\n * @param  {[type]} fileInfo [description]\n * @return {[type]}          [description]\n */\nfunction flattenInsertedContent(fileInfo) {\n  const [\n    rawJson,\n    jsonParentPath,\n    tmpPath,\n    content,\n  ] = fileInfo;\n\n  return processContent(content, tmpPath, rawJson);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/tags/index.js","export const isWin = /^win/.test(process.platform);\n\n\n\n// WEBPACK FOOTER //\n// ./src/util/platform.js","import { hasTagAttribute, getTagAttribute } from '../attributes';\nimport { processRawJson } from '../json';\nimport { getDataFromJsonPath } from '../util/parsing';\nimport { jsonPathAttribute } from '../config';\n\n// <!--#data jsonPath=\"\" default=\"\" -->\nexport default function processDataTag(tag, jsonContext) {\n  let jsonPath = \"\",\n      rawJson = \"\",\n      defaultValue = \"\",\n      jsonData = \"\";\n\n  jsonPath = getTagAttribute(jsonPathAttribute, tag);\n\n  if(hasTagAttribute(\"default\", tag))\n    defaultValue = getTagAttribute('default', tag);\n\n  if(hasTagAttribute('rawJson', tag)) {\n    rawJson = getTagAttribute('rawJson', tag);\n    rawJson = processRawJson(rawJson);\n  }\n  else if(jsonContext)\n    rawJson = processRawJson(jsonContext);\n\n  jsonData = getDataFromJsonPath(jsonPath, rawJson);\n  let result = jsonData || defaultValue;\n\n  return (typeof(result) === 'string')\n    ?  result\n    : JSON.stringify(result).replace(/\"/g, \"'\");\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/tags/data.js","import { hasTagAttribute, getTagAttribute, addTagAttribute } from '../attributes';\nimport { processRawJson, toSafeJsonString } from '../json';\nimport { getDataFromJsonPath, findIndexOfClosingTag } from '../util/parsing';\nimport { jsonPathAttribute } from '../config';\n\n// <!--#each count=\"\" jsonPath=\"\" rawJson=\"\" -->\n// <!--#endeach -->\nexport default function processEach(file, ndx, arr, jsonContext) {\n  let endNdx = -1,\n      startNdx = ndx + 1,\n      content = arr[ndx],\n      jsonPath = '',\n      rawJson = '',\n      jsonData = '',\n      count = false;\n\n  // find the closing tag for this each\n  endNdx = findIndexOfClosingTag('<!--#each', '<!--#endeach', ndx, arr);\n\n  // If we have no closing tag, then this is an error\n  if(endNdx === -1) {\n    console.error(\"ERROR: in file \" + file.path + \": <!--#each --> with no <!--#endeach -->\");\n    return;\n  }\n\n  // Maybe don't allow empty each tags\n  if(endNdx === (ndx - 1))\n    console.warn(\"WARNING: in file \" + file.path + \": <!--#each --> with no content\");\n\n  // look up the jsonPath used for this\n  if(hasTagAttribute(jsonPathAttribute, content))\n    jsonPath = getTagAttribute(jsonPathAttribute, content);\n\n  // see if there is rawJson on this, or get the jsonContext intead\n  if(hasTagAttribute('rawJson', content)) {\n    rawJson = getTagAttribute('rawJson', content);\n    rawJson = processRawJson(rawJson);\n  }\n  else if(jsonContext)\n    rawJson = processRawJson(jsonContext);\n\n  // if we have a path to look up data with, then use it\n  if(jsonPath)\n    jsonData = getDataFromJsonPath(jsonPath, rawJson);\n\n  // see if there is a hard coded loop count\n  if(hasTagAttribute('count', content))\n    count = parseInt(getTagAttribute('count', content), 10);\n\n  // Check if the jsonData is an array, if it is we should use it for the count\n  if(Array.isArray(jsonData)) {\n    // if we don't have a count, set it to length,\n    // else we will constrain how many items we will loop on\n    if(!count)\n      count = jsonData.length;\n    else if(count > jsonData.length) {\n      console.warn(\"WARNING: in file \" + file.path + \": <!--#each --> with count attribute higher than array input's length. Changing to length of array\");\n      count = jsonData.length;\n    }\n  }\n\n  // If there is no count and no jsonPath, then there is probably something forgotten\n  if(!count && !jsonPath) {\n    console.error(\"ERROR: in file \" + file.path + \": <!--#each --> with no count attribute, and no array as json object.\");\n    return;\n  }\n\n  ///\n  /// At this point we have the start and end indexes, and the data we are using\n  /// to render the content between the statements.\n  ///\n  /// The strategy used is to get this content, and then to duplicate it as many\n  /// times as the count. The content is all now within an array that replaces\n  /// everything from the current index to the index of the ending each tag.\n  ///\n\n  // clear end tag\n  arr[ndx] = '';\n  arr[endNdx] = '';\n\n  let middleMaster = arr.splice(startNdx, endNdx - startNdx).join('');\n\n  content = [];\n\n  // create all the duplicates of the data with the proper inserted data\n  for(let i = 0; i < count; i++)\n    if(jsonData)\n      content.push([jsonData[i], middleMaster ])\n    else\n      content.push(middleMaster);\n\n  // cut out original each, and replace with array\n  arr.splice(ndx, 2, content);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/tags/each.js","import { hasTagAttribute, getTagAttribute } from '../attributes';\nimport { processRawJson } from '../json';\nimport { getDataFromJsonPath, findIndexOfClosingTag } from '../util/parsing';\nimport { jsonPathAttribute } from '../config';\n\n// <!--#if jsonPath=\"\" rawJson=\"\" -->\n// <!--#endif -->\nexport default function processIf(file, ndx, arr, jsonContext) {\n  let endNdx = -1,\n      content = arr[ndx],\n      rawJson = \"\",\n      jsonPath = \"\",\n      jsonData;\n\n  if(hasTagAttribute(jsonPathAttribute, content))\n    jsonPath = getTagAttribute(jsonPathAttribute, content);\n\n  if(hasTagAttribute('rawJson', content)) {\n    rawJson = getTagAttribute('rawJson', content);\n    rawJson = processRawJson(rawJson);\n  }\n  else if(jsonContext)\n    rawJson = processRawJson(jsonContext);\n\n  jsonData = getDataFromJsonPath(jsonPath, rawJson);\n\n  // clear if statement\n  arr[ndx] = \"\";\n\n  endNdx = findIndexOfClosingTag('<!--#if', '<!--#endif', ndx, arr);\n\n  // If we have no closing tag, then this is an error\n  if(endNdx === -1) {\n    console.error(\"ERROR: in file \" + file.path + \": <!--#if . . . --> with no <!--#endif . . . -->\");\n    return;\n  }\n\n  // clear endif statement\n  arr[endNdx] = \"\";\n\n  // If there is no jsonPath we have no way to check the data ...\n  if(!jsonPath) {\n    console.error(\"ERROR: in file \" + file.path + \": <!--#if --> with no jsonPath\");\n    return;\n  }\n\n  // if undefined jsonData or false, then we eliminate the section\n  if(typeof(jsonData) === 'undefined' || jsonData == false)\n    arr.splice(ndx, endNdx - ndx);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/tags/if.js","import { hasTagAttribute, getTagAttribute } from '../attributes';\nimport { addRawJsonWhereJsonPath, appendJsonParentPath } from '../json';\nimport { buildPathFromRelativePath, updateRelativePaths } from '../util/file';\nimport { jsonPathAttribute, filePathAttribute, insertFiles } from '../config';\n\n// <!--#insert path=\"\" -->\nexport default function processInsert(file, jsonContext) {\n  let filename = \"\";\n  let content  = file.content;\n\n  let rawJson = (hasTagAttribute('rawJson', content))\n      ? getTagAttribute('rawJson', content)\n      : \"\";\n\n  let jsonParentPath = (hasTagAttribute(jsonPathAttribute, content))\n    ? getTagAttribute(jsonPathAttribute, content)\n    : \"\";\n\n  if(hasTagAttribute(filePathAttribute, content)) {\n    filename = getTagAttribute(filePathAttribute, content);\n    filename = buildPathFromRelativePath(file.path, filename);\n  }\n  else if(hasTagAttribute('absPath', content))\n    filename = getTagAttribute(\"absPath\", content)\n\n  if(insertFiles[filename])\n    content = insertFiles[filename].content;\n  else {\n    console.error(\"ERROR: in file '\" + file.path + \"': insert file `\" + filename + \"` does not exist\");\n    return \"\";\n  }\n\n  return [rawJson, jsonParentPath, file.tmpPath, content];\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/tags/insert.js","import { hasTagAttribute, getTagAttribute } from '../attributes';\nimport { getDataFromJsonPath } from '../util/parsing';\nimport { jsonPathAttribute } from '../config';\n\n// <!--#jsonInsert jsonPath=\"\" default=\"\" -->\nexport default function processJsonInsert(tag) {\n  let defaultValue = (hasTagAttribute(\"default\", tag))\n    ? getTagAttribute('default', tag)\n    : \"\";\n\n  let jsonPath = getTagAttribute(jsonPathAttribute, tag);\n  let jsonData = getDataFromJsonPath(jsonPath);\n\n  if(jsonData || defaultValue)\n    return jsonData || defaultValue;\n  else {\n    console.warn(\"ERROR: jsonPath `\" + jsonPath + \"` is undefined, and no default value\");\n    return \"\";\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/tags/jsonInsert.js","import { hasTagAttribute, getTagAttribute } from '../attributes';\nimport { jsonPathAttribute, filePathAttribute, wrapFiles, pathPattern } from '../config';\nimport { addRawJsonWhereJsonPath, appendJsonParentPath } from '../json';\nimport { buildPathFromRelativePath, updateRelativePaths } from '../util/file';\nimport { findIndexOfClosingTag } from '../util/parsing';\n\n// <!--#wrap path=\"\" jsonPath=\"\" rawJson=\"\" -->\n// <!--#middle -->\n// <!--#endwrap -->\nexport default function processWraps(file, ndx, arr, jsonContext) {\n  let endNdx = -1,\n      fpath = \"\",\n      content = arr[ndx],\n      filename = \"\",\n      rawJson = \"\",\n      jsonParentPath = \"\",\n      pathPattern = 'path=\"',\n      absPathPattern = 'absPath=\"',\n      pattern = (content.indexOf(pathPattern) > -1)\n        ? pathPattern\n        : absPathPattern;\n\n  // see if we are loading a json path\n  if(hasTagAttribute(jsonPathAttribute, content))\n    jsonParentPath = getTagAttribute(jsonPathAttribute, content);\n\n  // see if we have raw json to load from\n  if(hasTagAttribute('rawJson', content))\n    rawJson = getTagAttribute('rawJson', content);\n\n  // get filepath (either relative or absolute)\n  filename = (pattern === pathPattern)\n    ? getTagAttribute(filePathAttribute, arr[ndx])\n    : getTagAttribute(\"absPath\", arr[ndx]);\n\n  // build filepath if its relative\n  fpath = (pattern === pathPattern)\n    ? buildPathFromRelativePath(file.path, filename)\n    : filename;\n\n  // find closing tag\n  endNdx = findIndexOfClosingTag('<!--#wrap', '<!--#endwrap', ndx, arr);\n\n  // If we have no closing tag, then this is an error\n  if(endNdx === -1) {\n    console.error(\"ERROR: in file \" + file.path + \": <!--#wrap . . . --> with no <!--#endwrap . . . -->\");\n    return \"\";\n  }\n\n  // Get the wrap file and split it in the middle\n  if(wrapFiles[fpath]) {\n    content = wrapFiles[fpath].content.split(/<!--#middle\\s*-->/);\n    if(content.length !== 2) {\n      console.error(\"ERROR: in file \" + file.path + \": wrap file has no <!--#middle--> or more than one <!--#middle--> tags\");\n      return \"\";\n    }\n  }\n  else {\n    console.error(\"ERROR: in file \" + file.path + \": no wrapFile by the name `\" + filename + \"`\");\n    return \"\";\n  }\n\n  arr[ndx] = [rawJson, jsonParentPath, file.tmpPath, content[0]];\n  arr[endNdx] = [rawJson, jsonParentPath, file.tmpPath, content[1]];\n  return [ndx, endNdx];\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/tags/wrap.js"],"sourceRoot":""}