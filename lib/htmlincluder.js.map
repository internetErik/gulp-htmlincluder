{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/attributes/index.js","webpack:///./src/config.js","webpack:///./src/index.js","webpack:///./src/json/index.js","webpack:///./src/parse/index.js","webpack:///./src/tags/clip.js","webpack:///./src/tags/data.js","webpack:///./src/tags/each.js","webpack:///./src/tags/if.js","webpack:///./src/tags/index.js","webpack:///./src/tags/insert.js","webpack:///./src/tags/jsonInsert.js","webpack:///./src/tags/wrap.js","webpack:///./src/util/file.js","webpack:///./src/util/parsing.js","webpack:///./src/util/platform.js"],"names":["hasTagAttribute","getTagAttribute","setTagAttribute","changeTagAttributeName","removeTagAttribute","addTagAttribute","attr","content","indexOf","fndx","lndx","console","warn","slice","length","value","left","right","newAttr","middle","error","wrapFiles","insertFiles","pageFiles","options","devOptions","insertPattern","filePathAttribute","jsonPathAttribute","configureFiles","file","name","path","push","setOptions","ops","dev","module","exports","initialize","hashFile","f","buildFileResult","map","AST","jsonInput","replace","processed","callback","toSafeJsonString","processRawJson","appendJsonParentPath","addRawJsonWhereJsonPath","jsonObj","JSON","stringify","jsonString","jsonData","eval","e","jsonParentPath","fragment","ndx","arr","join","rawJson","data","bluntDataTagsInEaches","unbluntDataTagsInEaches","eachLevel","defaultNode","type","parent","children","nestedNodes","attributes","innerScope","jsonPath","json","buildAST","topNode","processNode","buildWrapAST","node","contentArr","filter","c","parseNodesToAst","resolveNode","closeTag","nodes","shift","findNodeType","forEach","loadNodeAttributes","processor","nodeProcessors","attrs","nodeAttributes","joinContent","nodeList","textContent","insert","getDataFromJsonPath","filename","wrap","log","childNode","wrapFile","wrapNode","fdd","sdfds","defaultVal","default","jsonInsert","each","if","result","split","reduce","acc","cur","Array","isArray","processClip","tmp","splice","processDataTag","tag","jsonContext","defaultValue","processEach","endNdx","startNdx","count","parseInt","middleMaster","i","processIf","processContent","splitArr","itterCount","contentBeforeProcessing","processSplitArray","printIterations","limitIterations","printResult","tempDirectory","pathStack","substr","hasPath","hasAbsPath","curFile","tmpPath","fileInfo","flattenInsertedContent","openNdx","closeNdx","flattenEach","processInsert","processJsonInsert","processWraps","fpath","pathPattern","absPathPattern","pattern","File","buildPathFromRelativePath","updateRelativePaths","contents","toString","trim","fixFilePathForOS","cdir","fdir","dir","dirChar","pop","printPaths","getIndexOfClosingBrace","splitContent","findIndexOfClosingTag","startPattern","endPattern","tagDepth","tmpContent","nextCloseNdx","nextOpenNdx","trace","tmpOpen","tmpClosed","partial","RAW_JSON_NDX","JSON_PATH_NDX","FILE_PATH_NDX","CONTENT_NDX","openTag","openCount","isWin","test","process","platform"],"mappings":"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GANS,EAMPG,IANO,CAMF,EANE,CAAV;;AAQA,MAAGK,YAAY,CAAf,EACE1D,QAAQS,KAAR,CAAc,mDAAd;;AAEF,SAAOb,OAAP;AACD;;AAED,SAAS6D,uBAAT,CAAiC7D,OAAjC,EAA0C;AACxCA,YAAUA,QAAQuC,OAAR,CAAgB,aAAhB,EAA+B,WAA/B,CAAV;AACA,SAAOvC,OAAP;AACD,C;;;;;;;;;;;;;;;;;;;;;;;AC3HD;;AACA;;AACA;;AACA;;AACA;;AAOA;;;;;;;;;;;;;;;;;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,IAAM+D,cAAc;AAClBC,QAAa,EADK;AAElBzC,QAAa,EAFK;AAGlBvB,WAAa,EAHK;AAIlBiE,UAAa,EAJK;AAKlBC,YAAa,EALK,EAKD;AACjB1B,aAAa,KANK;AAOlB2B,eAAc,EAPI,EAOA;AAClBC,cAAa,EARK,EAQD;AACjBC,cAAa,EATK;AAUlBC,YAAa,EAVK;AAWlBC,QAAa,EAXK,CAWD;AAXC,CAApB;;AAcA;AACO,IAAMC,8BAAW,SAAXA,QAAW,CAACjD,IAAD,EAAOgD,IAAP,EAAgB;;AAEtC;AACA,MAAME,uBACDV,WADC;AAEJC,UAAU,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","file":"htmlincluder.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","// does a tag have an attribute? (attributeName=\"value\")\nexport function hasTagAttribute(attr, content) {\n  // strip out inner tags\n  // check attribute existence\n  return content.indexOf(attr + '=\"') > -1;\n}\n\n// get the value of an attribute (attributeName=\"value\")\nexport function getTagAttribute(attr, content) {\n  var fndx = -1,\n      lndx = -1;\n\n  fndx = content.indexOf(attr + '=\"');\n  if(fndx === -1) {\n    console.warn(\"Warning: no tag of name `\" + attr + \"` found in the following content: `\" + content + \"`\")\n    return \"\";\n  }\n\n  content = content.slice(fndx + attr.length + 2);\n  lndx = content.indexOf('\"');\n  content = content.slice(0, lndx);\n  return content;\n}\n\n// set the value of an attribute (attributeName=\"value\")\nexport function setTagAttribute(attr, content, value) {\n  var fndx = -1,\n      lndx = -1,\n      left = \"\",\n      right = \"\";\n\n  fndx = content.indexOf(attr + '=\"');\n  left = content.slice(0, fndx + attr.length + 2);\n  content = content.slice(fndx + attr.length + 2);\n  lndx = content.indexOf('\"');\n  right = content.slice(lndx);\n  content = left + value + right;\n  return content;\n}\n\n// rename one attribute name to another (attributeName=\"value\")\nexport function changeTagAttributeName(attr, content, newAttr) {\n  var fndx = -1,\n      lndx = -1,\n      left = \"\",\n      right = \"\";\n\n  fndx = content.indexOf(attr + '=\"');\n  left = content.slice(0, fndx);\n  right = content.slice(fndx + attr.length);\n  return left + newAttr + right;\n}\n\n// removes an attribute from a tag along with its value (attributeName=\"value\")\nexport function removeTagAttribute(attr, content) {\n  var fndx = -1,\n      lndx = -1,\n      left = \"\",\n      right = \"\",\n      middle = content;\n\n  if(hasTagAttribute(attr, middle)) {\n    fndx = middle.indexOf(attr + '=\"');\n    left = middle.slice(0, fndx);\n    right = middle.slice(fndx + attr.length + 2);\n    // really naive for now - just look for another '\"'\n    lndx = right.indexOf('\"');\n    if(lndx === -1) {\n      console.error('ERROR: No close `\"` in tag ' + content)\n      return content;\n    }\n    else {\n      right = right.slice(lndx + 1);\n      middle = \"\";\n    }\n  }\n  return left + middle + right;\n}\n\n// adds an attribute from a tag along with a value (attributeName=\"value\")\nexport function addTagAttribute(attr, content, value) {\n  var fndx = -1,\n      lndx = -1,\n      left = \"\",\n      right = \"\",\n      middle = content;\n\n  lndx = middle.indexOf(\" \");\n  if(lndx > -1) {\n    left = middle.slice(0, lndx);\n    right = middle.slice(lndx);\n    middle = ` ${attr}=\"${value}\"`;\n  }\n\n  return left + middle + right;\n}\n","export const wrapFiles = {};\nexport const insertFiles = {};\nexport const pageFiles = [];\n\nexport let options = {};\nexport let devOptions = {};\nexport let insertPattern;\nexport let filePathAttribute;\nexport let jsonPathAttribute;\n\nexport const configureFiles = file => {\n  if(file.name[0] === '_')\n    wrapFiles[file.path] = file;\n  else if(file.name[0] === '-')\n    insertFiles[file.path] = file;\n  else\n    pageFiles.push(file);\n}\n\n// @options = (optional) options for configuring htmlIncluder\n// options.jsonInput         = A json object used to populate data in files\n// options.insertPattern     = The test looked for in order to insert files\n//          (this is so ssi includes can be used instead)\n// options.filePathAttribute = the name used for the file pathing for #insert\n//          and #wrap (default= 'path')\n// options.jsonPathAttribute = the name used for the file pathing for #insert\n//          , #wrap, #data, #jsonInsert (default= 'jsonPath')\n//\n//\n// options.dev.limitIterations = the number of times processFileWithJsonInput will loop\n// options.dev.printIterations = console log each processFileWithJsonInput loop\n// options.dev.printResult = console logs the final output\n// options.dev.printPaths = console logs the output of buildPathFromRelativePath\nexport const setOptions = ops => {\n  devOptions = ops.dev || {};\n  options = ops;\n\n  //set text value for insert tags, or default\n  insertPattern = (options.insertPattern)\n    ? '<!--#' + options.insertPattern\n    : '<!--#insert';\n\n  filePathAttribute = (options.filePathAttribute)\n    ? options.filePathAttribute\n    : 'path';\n\n  jsonPathAttribute = (options.jsonPathAttribute)\n    ? options.jsonPathAttribute\n    : 'jsonPath';\n}\n","import processClip from './tags/clip';\nimport processContent from './tags';\nimport { configureFiles, setOptions, pageFiles, options } from './config';\nimport { File } from './util/file';\nimport { buildAST } from './parse';\n\nmodule.exports = {\n  initialize : options => setOptions(options),\n  // puts files into hash maps\n  hashFile : file => {\n    const f = File(file);\n\n    // removing clip right away does no damage and speeds up later processing\n    processClip(f);\n\n    configureFiles(f);\n  },\n  // builds string\n  buildFileResult : callback => pageFiles.map(file => {\n    const AST = buildAST(file, options.jsonInput || {});\n\n    file.content = processContent(file.content, file.path, options.jsonInput || {});\n\n    // When an unknown tag is found it is changed to <!--!unknwn-tag# so that it doesn't\n    // continually get found. This will undo those changes\n    file.content = file.content.replace(/<!--!unknwn-tag#/g, '<!--#');\n    file.processed = true;\n\n    if(callback)\n      callback(file);\n\n    return file;\n  }),\n};\n","import { splitContent, getDataFromJsonPath } from '../util/parsing';\nimport { hasTagAttribute, addTagAttribute } from '../attributes';\nimport { jsonPathAttribute } from '../config';\n\n// given a jsonObj, we can convert it to a string for our purposes\nexport function toSafeJsonString(jsonObj) {\n  return JSON.stringify(jsonObj).replace(/\\'/g, \"\\\\'\").replace(/\"/g, \"'\")\n}\n\n// Handles the string value inside of rawJson=\"\" attributes\nexport function processRawJson(jsonString) {\n  var jsonData = {};\n\n  if(typeof(jsonString) === 'object')\n    jsonString = toSafeJsonString(jsonString);\n\n  try {\n    eval('jsonData = ' + jsonString);\n  }\n  catch(e) {\n    console.error('ERROR: Poorly formatted rawJson string: ' + jsonString + '\\n\\n This must be valid JavaScript.');\n  }\n\n  return jsonData;\n}\n\n// add json paths together\nexport function appendJsonParentPath(content, jsonParentPath) {\n  var fndx = -1,\n      lndx = -1,\n      left = \"\",\n      right = \"\";\n\n  // do nothing if there is no jsonParentPath\n  if(jsonParentPath === '' || jsonParentPath === 'this')\n    return content;\n\n  content = splitContent(content, '<!--#data'); // '' => ['']\n\n  // if we have an array larger than 1, then there is at least 1 insert to be made\n  if(content.length > 1) {\n\n    // process files\n    content = content.map(function(fragment, ndx, arr) {\n        if(fragment.indexOf('<!--#data') === 0) {\n          fndx = fragment.indexOf(`${jsonPathAttribute}=\"`)\n          if(fndx > -1) {\n            left = fragment.slice(0, fndx + 10);\n            fragment = left + jsonParentPath + '.' + fragment.slice(fndx + 10);\n          }\n          else {\n            console.error(\"ERROR: '<!--#data' tag with no 'jsonPath'\");\n          }\n        }\n        return fragment;\n      })\n\n  }\n  // re-join content into a string\n  content = content.join('') // [''] => ''\n  return content;\n}\n\n// splits up content into tags and puts rawJson in (if there isn't already a rawJson)\nexport function addRawJsonWhereJsonPath(content, rawJson, jsonParentPath) {\n  var fndx = -1,\n      lndx = -1,\n      left = \"\",\n      right = \"\";\n\n  // if we have a parent path, then we need to grab a subset of the rawJson\n  if(jsonParentPath && rawJson) {\n    let data = processRawJson(rawJson);\n    rawJson = getDataFromJsonPath(jsonParentPath, data);\n  }\n\n  content = bluntDataTagsInEaches(content);\n\n  content = splitContent(content); // '' => ['']\n\n  // if we have an array larger than 1, then there is at least 1 insert to be made\n  if(content.length > 1) {\n\n    // process files\n    content = content.map(function(fragment, ndx, arr) {\n        if(fragment.indexOf('<!--#') === 0 &&\n           hasTagAttribute(jsonPathAttribute, fragment) &&\n           !hasTagAttribute(\"rawJson\", fragment)\n          ) {\n          fragment = addTagAttribute(\"rawJson\", fragment, rawJson);\n        }\n        return fragment;\n      })\n\n  }\n  // re-join content into a string\n  content = content.join(''); // [''] => ''\n\n  content = unbluntDataTagsInEaches(content);\n  return content;\n}\n\nfunction bluntDataTagsInEaches(content) {\n  let arr = splitContent(content);\n  let eachLevel = 0;\n\n  content = arr.map((fragment, ndx, arr) => {\n    if(fragment.indexOf('<!--#each') === 0) eachLevel++;\n    if(fragment.indexOf('<!--#endeach') === 0) eachLevel--;\n    if(fragment.indexOf('<!--#data') === 0 && eachLevel > 0)\n      fragment = fragment.replace('<!--#data', '<!--@#data');\n    return fragment;\n  }).join('');\n\n  if(eachLevel > 0)\n    console.error('Error: Mismatched number of each and endeach tags');\n\n  return content;\n}\n\nfunction unbluntDataTagsInEaches(content) {\n  content = content.replace(/<!--@#data/g, '<!--#data');\n  return content;\n}\n","import { splitContent } from '../util/parsing';\nimport { hasTagAttribute, getTagAttribute } from '../attributes';\nimport { processRawJson } from '../json';\nimport { buildPathFromRelativePath } from '../util/file';\nimport {\n  jsonPathAttribute,\n  filePathAttribute,\n  insertFiles,\n  wrapFiles\n} from '../config';\n\n/*\n\n  string           - unparsed file\n  object           - node\n  array of objects - node list\n\n  1) convert a file (string) to a node\n  2) process the node\n    1) parse contents of node into a list of content and tags - both strings\n    2) resolve nested tags\n      - treat the string contents of a tag as a file\n    3) resolve tags to string\n      - each tag has its own process of being resolved\n  3) build string result by combining all child tags contents\n\n */\n\n// const insertFiles = { '/Users/erik/projects/gulp-htmlincluder/test/html/components/-base-component.html':\n//    { name: '-base-component.html',\n//      path:\n//       '/Users/erik/projects/gulp-htmlincluder/test/html/components/-base-component.html',\n//      content:\n//       '<div>\\n  This is a base component that may inherit something\\n  <!--#data jsonPath=\"inheritedProperty\" default=\"\" -->\\n</div>',\n//      processed: false,\n//      file: {\n//         cwd: '/Users/erik/projects/gulp-htmlincluder',\n//         base:\n//          '/Users/erik/projects/gulp-htmlincluder/test/html/components/',\n//         },\n//       },\n//   '/Users/erik/projects/gulp-htmlincluder/test/html/components/-customized-component.html':\n//    { name: '-customized-component.html',\n//      path:\n//       '/Users/erik/projects/gulp-htmlincluder/test/html/components/-customized-component.html',\n//      content:\n//       `<!--#insert\\n  path=\"./-base-component.html\"\\n  rawJson=\"{\\n    inheritedProperty: '<!--#data jsonPath=\"message\" default=\"\" -->',\\n  }\"\\n-->`,\n//      processed: false,\n//      file: {\n//         cwd: '/Users/erik/projects/gulp-htmlincluder',\n//         base:\n//          '/Users/erik/projects/gulp-htmlincluder/test/html/components/',\n//         },\n//       },\n//   '/Users/erik/projects/gulp-htmlincluder/test/html/components/-list.html':\n//    { name: '-list.html',\n//      path:\n//       '/Users/erik/projects/gulp-htmlincluder/test/html/components/-list.html',\n//      content:\n//       '<!--#each jsonPath=\"members\" -->\\n  <div>Name: <!--#data jsonPath=\"name\" --></div>\\n<!--#endeach -->',\n//      processed: false,\n//      file: {\n//         cwd: '/Users/erik/projects/gulp-htmlincluder',\n//         base:\n//          '/Users/erik/projects/gulp-htmlincluder/test/html/components/',\n//         },\n//       },\n//   '/Users/erik/projects/gulp-htmlincluder/test/html/components/-tab-collection.html':\n//    { name: '-tab-collection.html',\n//      path:\n//       '/Users/erik/projects/gulp-htmlincluder/test/html/components/-tab-collection.html',\n//      content:\n//       '<div class=\"tab-collection <!--#data jsonPath=\"className\" -->\">\\n  <div class=\"tab-collection__tabs\">\\n    <!--#each jsonPath=\"tabs\" -->\\n      <div class=\"tabs__tab <!--#data jsonPath=\"className\" -->\" data-tab-id=\"<!--#data jsonPath=\"tabId\" -->\">\\n        <!--#data jsonPath=\"displayName\" -->\\n      </div>\\n    <!--#endeach -->\\n  </div>\\n  <div class=\"tab-collection__contents\">\\n    <!--#each jsonPath=\"tabs\" -->\\n    <div class=\"contents__container\" data-tab-id=\"<!--#data jsonPath=\"tabId\" -->\">\\n      <!--#insert path=\"<!--#data jsonPath=\"filePath\" -->\" -->\\n    </div>\\n    <!--#endeach -->\\n  </div>\\n</div>',\n//      processed: false,\n//      file: {\n//         cwd: '/Users/erik/projects/gulp-htmlincluder',\n//         base:\n//          '/Users/erik/projects/gulp-htmlincluder/test/html/components/',\n//         },\n//       },\n//   '/Users/erik/projects/gulp-htmlincluder/test/html/components/-text-insert.html':\n//    { name: '-text-insert.html',\n//      path:\n//       '/Users/erik/projects/gulp-htmlincluder/test/html/components/-text-insert.html',\n//      content:\n//       'This is just a simple block of text inserted from -test-insert.html',\n//      processed: false,\n//      file: {\n//         cwd: '/Users/erik/projects/gulp-htmlincluder',\n//         base:\n//          '/Users/erik/projects/gulp-htmlincluder/test/html/components/',\n//         },\n//       },\n//   '/Users/erik/projects/gulp-htmlincluder/test/html/components/-with-json.html':\n//    { name: '-with-json.html',\n//      path:\n//       '/Users/erik/projects/gulp-htmlincluder/test/html/components/-with-json.html',\n//      content: '<!--#data jsonPath=\"text\" default=\"hello world!\" -->',\n//      processed: false,\n//      file: {\n//         cwd: '/Users/erik/projects/gulp-htmlincluder',\n//         base:\n//          '/Users/erik/projects/gulp-htmlincluder/test/html/components/',\n//          } }\n// };\n\n// const wrapFiles = { '/Users/erik/projects/gulp-htmlincluder/test/html/wrappers/_simple.html':\n//    { name: '_simple.html',\n//      path:\n//       '/Users/erik/projects/gulp-htmlincluder/test/html/wrappers/_simple.html',\n//      content:\n//       '<!DOCTYPE html>\\n<html lang=\"en\">\\n<head>\\n  <meta charset=\"UTF-8\">\\n  <title>Simple Wrapper</title>\\n</head>\\n<body>\\n  <!--#middle -->\\n</body>\\n</html>',\n//      processed: false,\n//      file: {\n//         cwd: '/Users/erik/projects/gulp-htmlincluder',\n//         base: '/Users/erik/projects/gulp-htmlincluder/test/html/wrappers/',\n//         },\n//       },\n//   '/Users/erik/projects/gulp-htmlincluder/test/html/wrappers/_with-json.html':\n//    { name: '_with-json.html',\n//      path:\n//       '/Users/erik/projects/gulp-htmlincluder/test/html/wrappers/_with-json.html',\n//      content:\n//       '<!DOCTYPE html>\\n<html lang=\"en\">\\n<head>\\n  <meta charset=\"UTF-8\">\\n  <title><!--#data jsonPath=\"title\" default=\"Wrapper With JSON\" --></title>\\n</head>\\n<body>\\n  <!--#middle -->\\n</body>\\n</html>',\n//      processed: false,\n//      file: {\n//         cwd: '/Users/erik/projects/gulp-htmlincluder',\n//         base: '/Users/erik/projects/gulp-htmlincluder/test/html/wrappers/',\n//          }\n//        },\n// };\n\n// const fakeFile = {\n//   name: 'simple.html',\n//   path: '/Users/erik/projects/gulp-htmlincluder/test/html/simple.html',\n//   content: `<!--#wrap path=\"./wrappers/_simple.html\" -->\\n  This is a simple file with a wrap and some inserts\\n  <!--#data\\n    jsonPath=\"<!--#jsonInsert jsonPath=\"hello\" default=\"jarl\" -->\"\\n    rawJson=\"{jarl : 'hello world'}\"\\n    default=\"jarlsense\"\\n  -->\\n  <!--#insert path=\"./components/-text-insert.html\" -->\\n<!--#endwrap -->`,\n//   processed: false,\n//   file: {}\n// }\n\n// const fakeJson = {};\n\n// shape of our AST nodes\nconst defaultNode = {\n  type       : '',\n  file       : {},\n  content    : '',\n  parent     : {},\n  children   : [], // list of sequential nodes wrapped in tag (or at topNode)\n  processed  : false,\n  nestedNodes : [], // nested tags - these need to be resolved before this tag is resolved\n  attributes : {}, // attributes on tag\n  innerScope : {},\n  jsonPath   : '',\n  json       : {}, // json values used for this tag\n};\n\n// entry point for processing files\nexport const buildAST = (file, json) => {\n\n  // convert string into object\n  const topNode = {\n    ...defaultNode,\n    type    : 'topNode',\n    file,\n    content : file.content,\n  };\n\n  // process children of the node\n  processNode(topNode, json);\n\n  // console.log('==================================')\n  // console.log(topNode.content);\n\n  return topNode;\n}\n\n// entry point for processing files\nexport const buildWrapAST = (file, parent, json) => {\n\n  // convert string into object\n  const topNode = {\n    ...defaultNode,\n    type    : 'topNode',\n    file,\n    parent,\n    content : file.content,\n  };\n\n  // process children of the node\n  processNode(topNode, json);\n\n  // console.log('==================================')\n  // console.log(topNode.content);\n\n  return topNode;\n}\n\n//\nconst processNode = (node, json) => {\n\n  // the contents of a node may contain more nested nodes\n  // break these up into an array of mixed textContent nodes and tags\n  const contentArr = splitContent(node.content).filter(c => c !== '');\n\n  // convert array of strings to nodes\n  node.nestedNodes = (contentArr[0] !== node.content)\n    ? parseNodesToAst(node, contentArr, json)\n    : [];\n\n// console.log('post nested: ', node.type)\n  resolveNode(node, json);\n}\n\n//\nconst parseNodesToAst = (parent, contentArr, json, closeTag) => {\n  const nodes = [];\n\n  while(contentArr.length > 0) {\n    const content = contentArr.shift();\n\n    // if we find the close tag, then close this\n    if(closeTag && content.indexOf(closeTag) === 0)\n      return nodes;\n\n    // lookup type of the tag\n    const type = findNodeType(content);\n\n    const node = {\n      ...defaultNode,\n      type,\n      parent,\n      file    : parent.file,\n      content,\n    };\n\n    // if this is a text node, we're set\n    if(type === 'textContent') {\n      node.processed = true;\n      nodes.push(node);\n      continue;\n    }\n\n    // remove leading character ('<') so the inner contents can be parsed properly\n    node.content = content.slice(1);\n\n    // the contents inside a node can be treated like new little documents\n\n    // if this is a node that has children build them up, removing them\n    // from the split up array\n    node.children = (\n        type === 'wrap' ? parseNodesToAst(node, contentArr, json, '<!--#endwrap')\n      : type === 'each' ? parseNodesToAst(node, contentArr, json, '<!--#endeach')\n      : type === 'if'   ? parseNodesToAst(node, contentArr, json, '<!--#endif')\n      : []\n    );\n\n    // handle all nested node\n    // skip if we are building up children\n    if(!closeTag)\n      processNode(node, json);\n\n    nodes.push(node);\n  }\n\n  return nodes;\n}\n\n//\nconst resolveNode = (node, json) => {\n  if(node.type === 'textContent') return;\n\n  if(node.children.length > 0) {\n    \n  }\n\n  // resolve nested tags\n  if(node.nestedNodes.length > 0) {\n    node.nestedNodes.forEach(node => resolveNode(node, json));\n    node.content = node.nestedNodes.map(c => c.content).join('');\n  }\n\n  // load and resolve attribute values\n  loadNodeAttributes(node);\n\n  // process node so that content is resolved\n  const processor = nodeProcessors[node.type] || (() =>{});\n  processor(node, json);\n\n  node.processed = true;\n}\n\n// check for tag and return node type\nconst findNodeType = content => (\n  content.indexOf('<!--#insert')     === 0 ? 'insert'\n: content.indexOf('<!--#data')       === 0 ? 'data'\n: content.indexOf('<!--#jsonInsert') === 0 ? 'jsonInsert'\n: content.indexOf('<!--#wrap')       === 0 ? 'wrap'\n: content.indexOf('<!--#middle')     === 0 ? 'middle'\n: content.indexOf('<!--#each')       === 0 ? 'each'\n: content.indexOf('<!--#if')         === 0 ? 'if'\n: 'textContent'\n)\n\n// loads values for tags into node object\nconst loadNodeAttributes = node => {\n  const attrs = nodeAttributes[node.type] || [];\n  attrs.forEach(attr => {\n    if(hasTagAttribute(attr, node.content)) {\n      const value = getTagAttribute(attr, node.content);\n      node.attributes[attr] = attr === 'rawJson' ? processRawJson(value) : value;\n    }\n  })\n}\n\nconst joinContent = nodeList => nodeList.map(c => c.content).join('')\n\n// the functions that processes each node\n// these assume that they have all their nested nodes resolved and attributes loaded\nconst nodeProcessors = {\n  //\n  topNode : (node, json) => {\n    node.content = joinContent(node.nestedNodes);\n  },\n  //\n  textContent : (node, json) => { console.warn('WARNING: Why are we processing a textContent?') },\n  //\n  insert : (node, json) => {\n    const { file } = node;\n    const { path, jsonPath, rawJson } = node.attributes;\n    if(!path) {\n      console.warn(`WARNING while processing file '${file.path}': insert tag with no path attribute`);\n      node.content = '';\n      return;\n    }\n    // set scope for inserted file\n    node.innerScope = (\n        jsonPath ? getDataFromJsonPath(jsonPath, json)\n      : rawJson  ? rawJson\n      : {}\n    );\n\n    // get filename for inserted file\n    const filename = buildPathFromRelativePath(file.path, path);\n\n    // see if file we are loading exists\n    if(!insertFiles[filename]) {\n      console.warn(`WARNING while processing file '${file.path}': insert file '${filename}' does not exist`);\n      node.content = '';\n      return;\n    }\n\n    // load contents from file\n    node.content = insertFiles[filename].content;\n\n    // process contents to get children\n    processNode(node, json);\n  },\n  //\n  wrap : (node, json) => {\n    const { file } = node;\n    const { path, jsonPath, rawJson } = node.attributes;\n    if(!path) {\n      console.warn(`WARNING while processing file '${file.path}': wrap tag with no path attribute`);\n      node.content = '';\n      return;\n    }\n\n    // set scope for inserted file\n    node.innerScope = (\n        jsonPath ? getDataFromJsonPath(jsonPath, json)\n      : rawJson  ? rawJson\n      : {}\n    );\n\n    // get filename for inserted file\n    const filename = buildPathFromRelativePath(file.path, path);\n\n    // see if file we are loading exists\n    if(!wrapFiles[filename]) {\n      console.warn(`WARNING while processing file '${file.path}': wrap file '${filename}' does not exist`);\n      node.content = '';\n      return;\n    }\n\nconsole.log(joinContent(node.children));\n    // handle children content\n    node.children.forEach(childNode => processNode(childNode, json))\n\n    node.content = joinContent(node.children);\n\n    // load contents from file\n    const wrapFile = wrapFiles[filename];\n    const wrapNode = buildWrapAST(wrapFile, node, json);\n// console.log(wrapNode);\nfdd +sdfds;\n\n    // process contents to get children\n    processNode(node, json);\n  },\n  //\n  middle : (node, json) => {\n    console.log(joinContent(node.parent.parent.children));\n  },\n  data : (node, json) => {\n    const { jsonPath, rawJson } = node.attributes;\n    const defaultVal = node.attributes.default;\n    console.log('processing data');\n    if(!rawJson || !jsonPath) {\n      node.content = '';\n      return;\n    }\n    const data = getDataFromJsonPath(jsonPath, rawJson);\n    node.content = data || defaultVal || '';\n  },\n  jsonInsert : (node, json) => {\n    const { jsonPath } = node.attributes;\n    const defaultVal = node.attributes.default;\n    if(!jsonPath) {\n      node.content = '';\n      return;\n    }\n    const data = getDataFromJsonPath(jsonPath, json);\n    node.content = data || defaultVal || '';\n  },\n  each : (node, json) => {\n\n  },\n  if : (node, json) => {\n\n  },\n}\n\n// the legal attributes for each element\nconst nodeAttributes = {\n  insert      : [ 'path', 'jsonPath', 'rawJson' ],\n  data        : [ 'jsonPath', 'rawJson', 'default' ],\n  jsonInsert  : [ 'jsonPath', 'default' ],\n  wrap        : [ 'path', 'jsonPath', 'rawJson' ],\n  middle      : [  ],\n  each        : [ 'count', 'jsonPath', 'rawJson' ],\n  if          : [ 'jsonPath', 'rawJson' ],\n  textContent : [  ],\n}\n\n// given a jsonObject and a path, return the data pointed at\nconst getDataFromJsonPath = (jsonPath, json) => {\n  if(jsonPath === 'this') return json;\n\n  let result = jsonPath.split('.').reduce((acc, cur) => acc ? acc[cur] : '', json)\n\n  if(!Array.isArray(result) && typeof(result) === 'object')\n    result = toSafeJsonString(result);\n\n  return result;\n}\n\n//\nconst toSafeJsonString = jsonObj =>\n  JSON.stringify(jsonObj).replace(/\\'/g, \"\\\\'\").replace(/\"/g, \"'\")\n","// <!--#clipbefore -->\n// <!--#clipafter -->\n// <!--#clipbetween -->\n// <!--#endclipbetween -->\n// This runs first, since all of the clipped areas will completely be removed\nexport default function processClip(file) {\n  var tmp;\n\n  if(file.content.indexOf('<!--#clipbefore') > -1) {\n\n    file.content = file.content\n            .split(/<!--#clipbefore\\s*-->/)\n            .splice(1)[0]\n            .split('<!--#clipafter')\n            .splice(0,1)[0];\n  }\n\n  if(file.content.indexOf('<!--#clipbetween') > -1) {\n\n    tmp = file.content\n        .split(/<!--#clipbetween\\s*-->/);\n\n    file.content = tmp[0] + tmp[1].split(/<!--#endclipbetween\\s*-->/)[1];\n  }\n}\n","import { hasTagAttribute, getTagAttribute } from '../attributes';\nimport { processRawJson } from '../json';\nimport { getDataFromJsonPath } from '../util/parsing';\nimport { jsonPathAttribute } from '../config';\n\n// <!--#data jsonPath=\"\" default=\"\" -->\nexport default function processDataTag(tag, jsonContext) {\n  let jsonPath = \"\",\n      rawJson = \"\",\n      defaultValue = \"\",\n      jsonData = \"\";\n\n  jsonPath = getTagAttribute(jsonPathAttribute, tag);\n\n  if(hasTagAttribute(\"default\", tag))\n    defaultValue = getTagAttribute('default', tag);\n\n  if(hasTagAttribute('rawJson', tag)) {\n    rawJson = getTagAttribute('rawJson', tag);\n    rawJson = processRawJson(rawJson);\n  }\n  else if(jsonContext)\n    rawJson = processRawJson(jsonContext);\n\n  jsonData = getDataFromJsonPath(jsonPath, rawJson);\n  let result = jsonData || defaultValue;\n\n  return (typeof(result) === 'string')\n    ?  result\n    : JSON.stringify(result).replace(/\"/g, \"'\");\n}\n","import { hasTagAttribute, getTagAttribute, addTagAttribute } from '../attributes';\nimport { processRawJson, toSafeJsonString } from '../json';\nimport { getDataFromJsonPath, findIndexOfClosingTag } from '../util/parsing';\nimport { jsonPathAttribute } from '../config';\n\n// <!--#each count=\"\" jsonPath=\"\" rawJson=\"\" -->\n// <!--#endeach -->\nexport default function processEach(file, ndx, arr, jsonContext) {\n  let endNdx = -1,\n      startNdx = ndx + 1,\n      content = arr[ndx],\n      jsonPath = '',\n      rawJson = '',\n      jsonData = '',\n      count = false;\n\n  // find the closing tag for this each\n  endNdx = findIndexOfClosingTag('<!--#each', '<!--#endeach', ndx, arr);\n\n  // If we have no closing tag, then this is an error\n  if(endNdx === -1) {\n    console.error(\"ERROR: in file \" + file.path + \": <!--#each --> with no <!--#endeach -->\");\n    return;\n  }\n\n  // Maybe don't allow empty each tags\n  if(endNdx === (ndx - 1))\n    console.warn(\"WARNING: in file \" + file.path + \": <!--#each --> with no content\");\n\n  // look up the jsonPath used for this\n  if(hasTagAttribute(jsonPathAttribute, content))\n    jsonPath = getTagAttribute(jsonPathAttribute, content);\n\n  // see if there is rawJson on this, or get the jsonContext intead\n  if(hasTagAttribute('rawJson', content)) {\n    rawJson = getTagAttribute('rawJson', content);\n    rawJson = processRawJson(rawJson);\n  }\n  else if(jsonContext)\n    rawJson = processRawJson(jsonContext);\n\n  // if we have a path to look up data with, then use it\n  if(jsonPath)\n    jsonData = getDataFromJsonPath(jsonPath, rawJson);\n\n  // see if there is a hard coded loop count\n  if(hasTagAttribute('count', content))\n    count = parseInt(getTagAttribute('count', content), 10);\n\n  // Check if the jsonData is an array, if it is we should use it for the count\n  if(Array.isArray(jsonData)) {\n    // if we don't have a count, set it to length,\n    // else we will constrain how many items we will loop on\n    if(!count)\n      count = jsonData.length;\n    else if(count > jsonData.length) {\n      console.warn(\"WARNING: in file \" + file.path + \": <!--#each --> with count attribute higher than array input's length. Changing to length of array\");\n      count = jsonData.length;\n    }\n  }\n\n  // If there is no count and no jsonPath, then there is probably something forgotten\n  if(!count && !jsonPath) {\n    console.error(\"ERROR: in file \" + file.path + \": <!--#each --> with no count attribute, and no array as json object.\");\n    return;\n  }\n\n  ///\n  /// At this point we have the start and end indexes, and the data we are using\n  /// to render the content between the statements.\n  ///\n  /// The strategy used is to get this content, and then to duplicate it as many\n  /// times as the count. The content is all now within an array that replaces\n  /// everything from the current index to the index of the ending each tag.\n  ///\n\n  // clear end tag\n  arr[ndx] = '';\n  arr[endNdx] = '';\n\n  let middleMaster = arr.splice(startNdx, endNdx - startNdx).join('');\n\n  content = [];\n\n  // create all the duplicates of the data with the proper inserted data\n  for(let i = 0; i < count; i++)\n    if(jsonData)\n      content.push([jsonData[i], middleMaster ])\n    else\n      content.push(middleMaster);\n\n  // cut out original each, and replace with array\n  arr.splice(ndx, 2, content);\n}\n","import { hasTagAttribute, getTagAttribute } from '../attributes';\nimport { processRawJson } from '../json';\nimport { getDataFromJsonPath, findIndexOfClosingTag } from '../util/parsing';\nimport { jsonPathAttribute } from '../config';\n\n// <!--#if jsonPath=\"\" rawJson=\"\" -->\n// <!--#endif -->\nexport default function processIf(file, ndx, arr, jsonContext) {\n  let endNdx = -1,\n      content = arr[ndx],\n      rawJson = \"\",\n      jsonPath = \"\",\n      jsonData;\n\n  if(hasTagAttribute(jsonPathAttribute, content))\n    jsonPath = getTagAttribute(jsonPathAttribute, content);\n\n  if(hasTagAttribute('rawJson', content)) {\n    rawJson = getTagAttribute('rawJson', content);\n    rawJson = processRawJson(rawJson);\n  }\n  else if(jsonContext)\n    rawJson = processRawJson(jsonContext);\n\n  jsonData = getDataFromJsonPath(jsonPath, rawJson);\n\n  // clear if statement\n  arr[ndx] = \"\";\n\n  endNdx = findIndexOfClosingTag('<!--#if', '<!--#endif', ndx, arr);\n\n  // If we have no closing tag, then this is an error\n  if(endNdx === -1) {\n    console.error(\"ERROR: in file \" + file.path + \": <!--#if . . . --> with no <!--#endif . . . -->\");\n    return;\n  }\n\n  // clear endif statement\n  arr[endNdx] = \"\";\n\n  // If there is no jsonPath we have no way to check the data ...\n  if(!jsonPath) {\n    console.error(\"ERROR: in file \" + file.path + \": <!--#if --> with no jsonPath\");\n    return;\n  }\n\n  // if undefined jsonData or false, then we eliminate the section\n  if(typeof(jsonData) === 'undefined' || jsonData == false)\n    arr.splice(ndx, endNdx - ndx);\n}\n","import { splitContent } from '../util/parsing';\nimport { buildPathFromRelativePath, updateRelativePaths } from '../util/file';\nimport { hasTagAttribute, getTagAttribute } from '../attributes';\nimport { addRawJsonWhereJsonPath, appendJsonParentPath } from '../json';\n\n// all the different tags we are going to process\nimport processDataTag     from './data';\nimport processEach        from './each';\nimport processIf          from './if';\nimport processInsert      from './insert';\nimport processJsonInsert  from './jsonInsert';\nimport processWraps       from './wrap';\n\nimport {\n  options,\n  devOptions,\n  insertPattern,\n  filePathAttribute,\n} from '../config';\n\n/**\n * Recursive function that does the major systematic work of htmlincluder\n *\n * 1) split content into an array of tags and non-tags\n * 2) if there are any tags (array.length > 1) loop until the parsing is finished\n *\n * @param  {String} content The text that we are processing the tags of\n * @param  {String} path    The current file path\n * @return {String}         The content, now parsed and with all tags replaces\n */\nexport default function processContent(content, path, jsonContext) {\n  let splitArr = [];\n  let itterCount = 0;\n\n  // create a tmp version of content to see if we actually do any work on it\n  let contentBeforeProcessing = content;\n\n  // prime loop: split content into all insertion points\n  splitArr = splitContent(content); // '' => ['']\n\n  // if we have an array larger than 1, then there is at least 1 insert to be made\n  while(splitArr.length > 1) {\n\n    splitArr = processSplitArray(splitArr, path, jsonContext);\n\n    // At this point we should have a mix of strings and arrays\n    // We need to loop through again and process each of the arrays\n\n    // re-join content into a string, and repeat\n    content = splitArr.join(''); // [''] => ''\n\n    // We split the string, so there should have been work. Was there?\n    if(content === contentBeforeProcessing) {\n      console.error('Content was split, but no change was made in it: ' + content);\n      console.error('Something in your tagging may be making it impossible to process correctly')\n      console.error('Returning the content without further processing')\n      return content;\n    }\n\n    // split file into all insertion points\n    splitArr = splitContent(content); // '' => ['']\n\n    // debug features\n    if(devOptions.printIterations)\n      console.log(content);\n\n    if(devOptions.limitIterations) {\n      itterCount++;\n      if(itterCount >= devOptions.limitIterations)\n        break;\n    }\n  }\n\n  if(devOptions.printResult)\n    console.log(content);\n\n  return content;\n}\n\n/**\n * Loops through split content. For each tag, it makes a call back up to\n * processContent in order to take care of any inner tags.\n *\n * Once there are no more inner tags, we look at the tag, and depending on its\n * kind, we run a different tag processor on it.\n *\n * @param  {Array}  splitArr    The array of split up tags\n * @param  {String} path        The file path we are currently using for relative paths\n * @param  {Object} jsonContext The json data consumable by tags in this context\n * @return {Array}              The array, having made one pass to process it\n */\nfunction processSplitArray(splitArr, path, jsonContext) {\n  let tempDirectory;\n  let pathStack = path;\n  // iterate through content\n  for(let i = 0; i < splitArr.length; i++) {\n    let fragment = splitArr[i];\n\n    if(fragment.indexOf('<!--#') === 0) {\n      // process any tags inside of this tag\n      fragment = '<' + processContent(fragment.substr(0, fragment.length - 1).substr(1), path, jsonContext) + '>';\n\n      //\n      // At this point we can assume that the tag we are working with has no\n      // embedded tags.\n      //\n\n      // See if this has a file path, or absolute file path. If we don't have\n      // an absolute path, then we need to build one.\n      let hasPath = hasTagAttribute(filePathAttribute, fragment);\n      let hasAbsPath = hasTagAttribute(\"absPath\", fragment);\n\n      // get or build paths\n      if(hasPath)\n        tempDirectory = buildPathFromRelativePath(pathStack, getTagAttribute(filePathAttribute, fragment));\n      else if(hasAbsPath) {\n        tempDirectory = getTagAttribute(\"absPath\", fragment);\n        pathStack = tempDirectory;\n      }\n\n      let curFile = {\n        content: fragment,\n        path: pathStack,\n        tmpPath: tempDirectory,\n      };\n\n      // handle loading each particular kind of tag\n      if(fragment.indexOf('<!--#data') === 0) {\n        splitArr[i] = processDataTag(fragment, jsonContext);\n      }\n      else if(fragment.indexOf('<!--#jsonInsert') === 0) {\n        splitArr[i] = processJsonInsert(fragment);\n      }\n      else if(fragment.indexOf(insertPattern) === 0) {\n        const fileInfo = processInsert(curFile, jsonContext);\n        splitArr[i] = flattenInsertedContent(fileInfo);\n      }\n      else if(fragment.indexOf('<!--#wrap') === 0) {\n        const [openNdx, closeNdx] = processWraps(curFile, i, splitArr, jsonContext);\n        splitArr[openNdx] = flattenInsertedContent(splitArr[openNdx]);\n        splitArr[closeNdx] = flattenInsertedContent(splitArr[closeNdx]);\n      }\n      else if(fragment.indexOf('<!--#if') === 0) {\n        processIf(curFile, i, splitArr, jsonContext)\n      }\n      else if(fragment.indexOf('<!--#each') === 0) {\n        processEach(curFile, i, splitArr, jsonContext);\n        splitArr[i] = flattenEach(splitArr[i], pathStack);\n      }\n      else {\n        console.error('An unidentified tag is being used: ' + fragment);\n        splitArr[i] = fragment.replace('<!--#', '<!--!unknwn-tag#');\n      }\n\n      pathStack = path;\n    }\n  }\n\n  return splitArr;\n}\n\n/**\n * The result of each tags produce an array that lumps together the expanded\n * content between the two tags.\n *\n * It does this by running through the array, and if data is needed, it runs\n * it through processContent. Otherwise it simply adds it to a string.\n *\n * @param  {Array}  fragment The collection of content between the each tags\n * @param  {String} path     The current file path\n * @return {String}          Processed content between each\n */\nfunction flattenEach(fragment, path) {\n\n  if(!Array.isArray(fragment))\n    return fragment;\n\n  let result = '';\n  for(let i = 0; i < fragment.length; i++) {\n    if(Array.isArray(fragment[i])) {\n      const [ data, content ] = fragment[i];\n      result += processContent(content, path, data);\n    }\n    else\n      result += fragment[i];\n  }\n\n  return result;\n}\n\n/**\n * When an #insert or #wrap/#endwrap parse runs it inserts an array into its\n * spot. Then it will flatten this out\n * @param  {[type]} fileInfo [description]\n * @return {[type]}          [description]\n */\nfunction flattenInsertedContent(fileInfo) {\n  const [\n    rawJson,\n    jsonParentPath,\n    tmpPath,\n    content,\n  ] = fileInfo;\n\n  return processContent(content, tmpPath, rawJson);\n}\n","import { hasTagAttribute, getTagAttribute } from '../attributes';\nimport { addRawJsonWhereJsonPath, appendJsonParentPath } from '../json';\nimport { buildPathFromRelativePath, updateRelativePaths } from '../util/file';\nimport { jsonPathAttribute, filePathAttribute, insertFiles } from '../config';\n\n// <!--#insert path=\"\" -->\nexport default function processInsert(file, jsonContext) {\n  let filename = \"\";\n  let content  = file.content;\n\n  let rawJson = (hasTagAttribute('rawJson', content))\n      ? getTagAttribute('rawJson', content)\n      : \"\";\n\n  let jsonParentPath = (hasTagAttribute(jsonPathAttribute, content))\n    ? getTagAttribute(jsonPathAttribute, content)\n    : \"\";\n\n  if(hasTagAttribute(filePathAttribute, content)) {\n    filename = getTagAttribute(filePathAttribute, content);\n    filename = buildPathFromRelativePath(file.path, filename);\n  }\n  else if(hasTagAttribute('absPath', content))\n    filename = getTagAttribute(\"absPath\", content)\n\n  if(insertFiles[filename])\n    content = insertFiles[filename].content;\n  else {\n    console.error(\"ERROR: in file '\" + file.path + \"': insert file `\" + filename + \"` does not exist\");\n    return \"\";\n  }\n\n  return [rawJson, jsonParentPath, file.tmpPath, content];\n}\n","import { hasTagAttribute, getTagAttribute } from '../attributes';\nimport { getDataFromJsonPath } from '../util/parsing';\nimport { jsonPathAttribute } from '../config';\n\n// <!--#jsonInsert jsonPath=\"\" default=\"\" -->\nexport default function processJsonInsert(tag) {\n  let defaultValue = (hasTagAttribute(\"default\", tag))\n    ? getTagAttribute('default', tag)\n    : \"\";\n\n  let jsonPath = getTagAttribute(jsonPathAttribute, tag);\n  let jsonData = getDataFromJsonPath(jsonPath);\n\n  if(jsonData || defaultValue)\n    return jsonData || defaultValue;\n  else {\n    console.warn(\"ERROR: jsonPath `\" + jsonPath + \"` is undefined, and no default value\");\n    return \"\";\n  }\n}\n","import { hasTagAttribute, getTagAttribute } from '../attributes';\nimport { jsonPathAttribute, filePathAttribute, wrapFiles, pathPattern } from '../config';\nimport { addRawJsonWhereJsonPath, appendJsonParentPath } from '../json';\nimport { buildPathFromRelativePath, updateRelativePaths } from '../util/file';\nimport { findIndexOfClosingTag } from '../util/parsing';\n\n// <!--#wrap path=\"\" jsonPath=\"\" rawJson=\"\" -->\n// <!--#middle -->\n// <!--#endwrap -->\nexport default function processWraps(file, ndx, arr, jsonContext) {\n  let endNdx = -1,\n      fpath = \"\",\n      content = arr[ndx],\n      filename = \"\",\n      rawJson = \"\",\n      jsonParentPath = \"\",\n      pathPattern = 'path=\"',\n      absPathPattern = 'absPath=\"',\n      pattern = (content.indexOf(pathPattern) > -1)\n        ? pathPattern\n        : absPathPattern;\n\n  // see if we are loading a json path\n  if(hasTagAttribute(jsonPathAttribute, content))\n    jsonParentPath = getTagAttribute(jsonPathAttribute, content);\n\n  // see if we have raw json to load from\n  if(hasTagAttribute('rawJson', content))\n    rawJson = getTagAttribute('rawJson', content);\n\n  // get filepath (either relative or absolute)\n  filename = (pattern === pathPattern)\n    ? getTagAttribute(filePathAttribute, arr[ndx])\n    : getTagAttribute(\"absPath\", arr[ndx]);\n\n  // build filepath if its relative\n  fpath = (pattern === pathPattern)\n    ? buildPathFromRelativePath(file.path, filename)\n    : filename;\n\n  // find closing tag\n  endNdx = findIndexOfClosingTag('<!--#wrap', '<!--#endwrap', ndx, arr);\n\n  // If we have no closing tag, then this is an error\n  if(endNdx === -1) {\n    console.error(\"ERROR: in file \" + file.path + \": <!--#wrap . . . --> with no <!--#endwrap . . . -->\");\n    return \"\";\n  }\n\n  // Get the wrap file and split it in the middle\n  if(wrapFiles[fpath]) {\n    content = wrapFiles[fpath].content.split(/<!--#middle\\s*-->/);\n    if(content.length !== 2) {\n      console.error(\"ERROR: in file \" + file.path + \": wrap file has no <!--#middle--> or more than one <!--#middle--> tags\");\n      return \"\";\n    }\n  }\n  else {\n    console.error(\"ERROR: in file \" + file.path + \": no wrapFile by the name `\" + filename + \"`\");\n    return \"\";\n  }\n\n  arr[ndx] = [rawJson, jsonParentPath, file.tmpPath, content[0]];\n  arr[endNdx] = [rawJson, jsonParentPath, file.tmpPath, content[1]];\n  return [ndx, endNdx];\n}\n","import { isWin } from './platform';\nimport { getTagAttribute, setTagAttribute, changeTagAttributeName } from '../attributes';\nimport { splitContent } from './parsing';\nimport { devOptions, insertPattern, filePathAttribute } from '../config';\n\nexport function File(file) {\n  var f = {\n    name : '',\n    path : file.path,\n    content : file.contents.toString('utf8').trim(),\n    processed : false,\n    file : file\n  };\n\n  f.name = (isWin) ? file.path.split('\\\\') : file.path.split('/');\n  f.name = f.name[f.name.length-1];\n\n  return f;\n}\n\n// overcome the difference in *nix/windows pathing\nfunction fixFilePathForOS(path) {\n  return (isWin) ? path.replace(/\\//g, '\\\\') : path.replace(/\\\\/g, '/');\n}\n\n// given the current directory and a relative path, build the complete path\n// to the relative path\nexport function buildPathFromRelativePath(cdir, fdir) {\n  var dir,\n      dirChar = (isWin) ? '\\\\' : '/';\n\n  dir = cdir.split(dirChar);\n\n  fdir = fixFilePathForOS(fdir);\n  dir.pop();\n\n  fdir.split(dirChar)\n    .forEach(function(e) {\n      (e === '..') ? dir.pop() : (e !== '.' && e !== '') ? dir.push(e) : void 0;\n    });\n  dir = dir.join(dirChar);\n  if(devOptions.printPaths) {\n    console.log(\"********buildPathFromRelativePath********\")\n    console.log(\"cdir  : \", cdir)\n    console.log(\"fdir  : \", fdir)\n    console.log(\"result: \", dir)\n    console.log(\"********end buildPathFromRelativePath********\")\n  }\n  return dir;\n}\n\n// Updates the relative path with the parent's path so it can be resolved on the\n// next turn\nexport function updateRelativePaths(content, cdir) {\n  var dir = \"\";\n  content = splitContent(content);\n\n  content = content.map(function(fragment) {\n    if(fragment.indexOf(insertPattern)  === 0 ||\n       fragment.indexOf('<!--#wrap')    === 0) {\n      dir = getTagAttribute(filePathAttribute, fragment);\n      dir = buildPathFromRelativePath(cdir, dir);\n      fragment = setTagAttribute(filePathAttribute, fragment, dir);\n      fragment = changeTagAttributeName(filePathAttribute, fragment, \"absPath\");\n    }\n    return fragment;\n  })\n\n  content = content.join('');\n  return content;\n}","import { toSafeJsonString } from '../json';\nimport { options } from '../config';\n\n// given a jsonObject and a path, return the data pointed at\nexport function getDataFromJsonPath(jsonPath, jsonObj) {\n  var json = jsonObj || options.jsonInput;\n  var result;\n\n  if(jsonPath === '*') return options.jsonInput;\n  if(jsonPath === 'this') return json;\n  result = jsonPath.split('.').reduce((acc, cur) => acc ? acc[cur] : '', json)\n\n  if(Array.isArray(result));\n  else if(typeof(result) === 'object')\n    result = toSafeJsonString(result);\n\n  return result;\n}\n\n// Given some content (starting with a tag) find the index after the matching end tag\nexport function getIndexOfClosingBrace(content, startPattern, endPattern) {\n  let tagDepth = 0;// when this gets to 0 we are done\n  let tmpContent = content.substr(1);\n\n\n  // prime loop by finding next start tag\n  let nextCloseNdx = tmpContent.indexOf(endPattern);\n  let nextOpenNdx = tmpContent.indexOf(startPattern);\n\n  if(nextCloseNdx ===  -1)\n    console.trace(`No Close tag for startPattern: ${startPattern} and endPattern: ${endPattern} and content: ${content}`);\n\n  // if there is a nextCloseNdx, but no openNdx, return the end of the tag.\n  if(nextOpenNdx === -1 || nextOpenNdx > nextCloseNdx)\n    return nextCloseNdx + 4; // 4 not 3 because we sliced off the '<' in content\n\n  // add 1 so we will search past the tag\n  nextOpenNdx += 1;\n  nextCloseNdx += 1;\n\n  // while current tag is not closed...\n  do {\n    let tmpOpen, tmpClosed;\n\n    // start tag is before close tag, then\n    // we can look to see if there is yet another tag nested between\n    if(nextOpenNdx > -1 && nextOpenNdx < nextCloseNdx) {\n      tmpOpen = tmpContent.substr(nextOpenNdx).indexOf(startPattern);\n      // see if we found something, and add this new index to our accumulator\n      if(tmpOpen > -1) {\n        // add 1 because we need next search to be beyond this tag\n        nextOpenNdx += tmpOpen + 2;\n        tagDepth += 1;\n      }\n      else\n        nextOpenNdx = -1;\n    }\n    else { // current close tag is before start tag\n      tmpClosed = tmpContent.substr(nextCloseNdx).indexOf(endPattern);\n      // see if we found something, and add this new index to our accumulator\n      if(tmpClosed > -1) {\n        // add 1 because we need next search to be beyond this tag\n        nextCloseNdx += tmpClosed + 1;\n        tagDepth -= 1;\n\n        if(tagDepth === 0)\n          return nextCloseNdx + 3;\n      }\n      else if(tagDepth > 0) {\n        console.error('There is an unclosed tag', content);\n        break;\n      }\n    }\n  } while(tagDepth > 0)\n\n  nextCloseNdx += 4;\n\n  if(nextCloseNdx === -1)\n    console.error(\"ERROR: no closing tag! you are missing a '\" + endPattern + \"'\");\n\n\n  return nextCloseNdx;\n}\n\n// Splits a string into an array where special tags are on their own\n// can optionally only split it up based on a particular tag\nexport function splitContent(content, tag) {\n  let arr = [],\n      openNdx = -1,\n      closeNdx = -1,\n      partial = \"\",\n      startPattern = tag || '<!--#',\n      endPattern = '-->';\n\n  //prime the loop\n  openNdx = content.indexOf(startPattern);\n\n  if(openNdx === -1)\n    return [content];\n\n  while(openNdx > -1) {\n    partial = content.slice(0, openNdx);\n    if(partial)\n      arr.push(partial);\n\n    content = content.slice(openNdx);\n\n    // get the closeNdx despite inner open tags\n    // openNdx-><!-- <!-- --> <!-- <!-- --> --> --><-closeNdx\n    let closeNdx = getIndexOfClosingBrace(content, startPattern, endPattern);\n\n    partial = content.slice(0, closeNdx);\n    arr.push(partial);\n    content = content.slice(closeNdx);\n\n    // get ready for next iteration\n    openNdx = content.indexOf(startPattern);\n\n    // on final pass, push the remainer of the content string\n    if(openNdx === -1)\n      arr.push(content);\n  }\n\n  // Now we have an array of tags, and content\n  return arr;\n}\n\n// ToDo. These should go to a better place, for now only one place was using a\n// magic number\nconst RAW_JSON_NDX  = 0;\nconst JSON_PATH_NDX = 1;\nconst FILE_PATH_NDX = 2;\nconst CONTENT_NDX   = 3;\n\n// returns the index of the closing tag for a given opening tag\nexport function findIndexOfClosingTag(openTag, closeTag, startNdx, arr) {\n  var endNdx = -1;\n  var openCount = 1;\n\n  for(var i = startNdx + 1; i < arr.length; i++) {\n    let fragment = (Array.isArray(arr[i]))\n      ? arr[i][CONTENT_NDX] // [i] contains [rawJson, jsonPath, filePath, content]\n      : arr[i];\n\n    if(fragment.indexOf(openTag) === 0)\n      openCount++;\n    else if(fragment.indexOf(closeTag) === 0) {\n      openCount--;\n      if(openCount === 0) {\n        endNdx = i;\n        break;\n      }\n    }\n  }\n  return endNdx;\n}\n","export const isWin = /^win/.test(process.platform);\n"],"sourceRoot":""}