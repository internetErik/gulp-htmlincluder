{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/config.js","webpack:///./src/index.js","webpack:///./src/parse.js"],"names":["wrapFiles","insertFiles","pageFiles","options","devOptions","insertPattern","filePathAttribute","jsonPathAttribute","configureFiles","file","name","path","push","setOptions","ops","dev","module","exports","initialize","hashFile","f","File","processClip","buildFileResult","map","AST","jsonInput","content","console","log","processed","callback","isWin","test","process","platform","contents","toString","trim","split","length","tmp","indexOf","splice","getDefaultNode","type","originalContent","parent","innerScope","children","nestedNodes","attributes","processFile","json","topNode","processNode","node","contentArr","splitContent","filter","c","buildNodes","resolveNode","closeTag","nodes","shift","findNodeType","slice","warn","forEach","joinContent","processor","nodeProcessors","loadNodeAttributes","attrs","nodeAttributes","reduce","acc","attr","hasTagAttribute","value","getTagAttribute","processRawJson","nodeList","join","textContent","insert","jsonPath","rawJson","filename","buildPathFromRelativePath","insertFile","newInnerScope","getDataFromJsonPath","insertNode","wrap","childNode","wrapFile","wrapNode","middle","data","defaultVal","default","values","jsonInsert","each","count","Array","isArray","jsonData","tmpContent","i","tmpChildren","if","tag","arr","openNdx","closeNdx","partial","startPattern","endPattern","getIndexOfClosingBrace","tagDepth","substr","nextCloseNdx","nextOpenNdx","trace","tmpOpen","tmpClosed","error","result","cur","toSafeJsonString","fixFilePathForOS","replace","cdir","fdir","dirChar","dir","pop","e","JSON","stringify","jsonObj","jsonString","eval","fndx","lndx"],"mappings":"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","file":"htmlincluder.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","export const wrapFiles = {};\nexport const insertFiles = {};\nexport const pageFiles = [];\n\nexport let options = {};\nexport let devOptions = {};\nexport let insertPattern;\nexport let filePathAttribute;\nexport let jsonPathAttribute;\n\nexport const configureFiles = file => {\n  if(file.name[0] === '_')\n    wrapFiles[file.path] = file;\n  else if(file.name[0] === '-')\n    insertFiles[file.path] = file;\n  else\n    pageFiles.push(file);\n}\n\n// @options = (optional) options for configuring htmlIncluder\n// options.jsonInput         = A json object used to populate data in files\n// options.insertPattern     = The test looked for in order to insert files\n//          (this is so ssi includes can be used instead)\n// options.filePathAttribute = the name used for the file pathing for #insert\n//          and #wrap (default= 'path')\n// options.jsonPathAttribute = the name used for the file pathing for #insert\n//          , #wrap, #data, #jsonInsert (default= 'jsonPath')\n//\n//\n// options.dev.limitIterations = the number of times processFileWithJsonInput will loop\n// options.dev.printIterations = console log each processFileWithJsonInput loop\n// options.dev.printResult = console logs the final output\n// options.dev.printPaths = console logs the output of buildPathFromRelativePath\nexport const setOptions = ops => {\n  devOptions = ops.dev || {};\n  options = ops;\n\n  //set text value for insert tags, or default\n  insertPattern = (options.insertPattern)\n    ? '<!--#' + options.insertPattern\n    : '<!--#insert';\n\n  filePathAttribute = (options.filePathAttribute)\n    ? options.filePathAttribute\n    : 'path';\n\n  jsonPathAttribute = (options.jsonPathAttribute)\n    ? options.jsonPathAttribute\n    : 'jsonPath';\n}\n","import { configureFiles, setOptions, pageFiles, options } from './config';\nimport { processFile } from './parse';\n\nmodule.exports = {\n  initialize : options => setOptions(options),\n  // puts files into hash maps\n  hashFile : file => {\n    const f = File(file);\n\n    // removing clip right away does no damage and speeds up later processing\n    processClip(f);\n\n    configureFiles(f);\n  },\n  // builds string\n  buildFileResult : callback => pageFiles.map(file => {\n    const AST = processFile(file, options.jsonInput || {});\n    file.content = AST.content;\n    console.log(file.content);\n    file.processed = true;\n\n    if(callback)\n      callback(file);\n\n    return file;\n  }),\n};\n\nconst isWin = /^win/.test(process.platform);\n\nfunction File(file) {\n  var f = {\n    name : '',\n    path : file.path,\n    content : file.contents.toString('utf8').trim(),\n    processed : false,\n    file : file\n  };\n\n  f.name = (isWin) ? file.path.split('\\\\') : file.path.split('/');\n  f.name = f.name[f.name.length-1];\n\n  return f;\n}\n\n// <!--#clipbefore -->\n// <!--#clipafter -->\n// <!--#clipbetween -->\n// <!--#endclipbetween -->\n// This runs first, since all of the clipped areas will completely be removed\nfunction processClip(file) {\n  var tmp;\n\n  if(file.content.indexOf('<!--#clipbefore') > -1) {\n\n    file.content = file.content\n            .split(/<!--#clipbefore\\s*-->/)\n            .splice(1)[0]\n            .split('<!--#clipafter')\n            .splice(0,1)[0];\n  }\n\n  if(file.content.indexOf('<!--#clipbetween') > -1) {\n\n    tmp = file.content\n        .split(/<!--#clipbetween\\s*-->/);\n\n    file.content = tmp[0] + tmp[1].split(/<!--#endclipbetween\\s*-->/)[1];\n  }\n}\n","import {\n  jsonPathAttribute,\n  filePathAttribute,\n  insertFiles,\n  wrapFiles,\n  options,\n  devOptions,\n  insertPattern,\n} from './config';\n\n// shape of our AST nodes\nconst getDefaultNode = () => ({\n  type            : '',\n  file            : {},\n  originalContent : '',\n  content         : '',\n  parent          : {},\n  innerScope      : null,\n  children        : [], // list of sequential nodes wrapped in tag (or at topNode)\n  nestedNodes     : [], // nested tags - these need to be resolved before this tag is resolved\n  attributes      : {}, // attributes on tag\n})\n\n// entry point for processing files\nexport const processFile = (file, json, parent, innerScope) => {\n  // convert string into object\n  const topNode = {\n    ...getDefaultNode(),\n    type    : 'topNode',\n    file,\n    originalContent: file.content,\n    content : file.content,\n    ...(parent     ? { parent }     : {}),\n    ...(innerScope ? { innerScope } : {}),\n  };\n\n  // don't do work if there are no tags in the file\n  if(topNode.originalContent.indexOf('<!--#') === -1)\n    return topNode;\n\n  // process children of the node\n  processNode(topNode, json);\n\n  return topNode;\n}\n\n//\nconst processNode = (node, json) => {\n  if(node.type === 'textContent') return;\n\n  // the contents of a node may contain more nested nodes\n  // break these up into an array of mixed textContent nodes and tags\n  const contentArr = splitContent(node.content).filter(c => c !== '');\n\n  // convert array of strings to nodes\n  node.nestedNodes = buildNodes(node, contentArr, json);\n\n  resolveNode(node, json);\n}\n\n//\nconst buildNodes = (parent, contentArr, json, closeTag) => {\n  const nodes = [];\n\n  while(contentArr.length > 0) {\n    const content = contentArr.shift();\n\n    // if we find the close tag, then we are done with our search\n    if(closeTag && content.indexOf(closeTag) === 0)\n      return nodes;\n\n    // lookup type of the tag\n    const type = findNodeType(content);\n\n    const node = {\n      ...getDefaultNode(),\n      type,\n      parent,\n      file            : parent.file,\n      innerScope      : parent.innerScope,\n      originalContent : content,\n      content,\n    };\n\n    // if this is a text node, we're set\n    if(type === 'textContent') {\n      nodes.push(node);\n      continue;\n    }\n\n    // remove leading character ('<') so the inner contents can be parsed properly\n    node.content = node.originalContent.slice(1);\n\n    // the contents inside a node can be treated like new little documents\n\n    // if this is a node that has children build them up, removing them\n    // from the split up array\n    node.children = (\n        type === 'wrap' ? buildNodes(node, contentArr, json, '<!--#endwrap')\n      : type === 'each' ? buildNodes(node, contentArr, json, '<!--#endeach')\n      : type === 'if'   ? buildNodes(node, contentArr, json, '<!--#endif')\n      : []\n    );\n\n    nodes.push(node);\n  }\n\n  // We should never get here while looking for a closing tag\n  if(closeTag)\n    console.warn(`WARNING while processing file '${parent.file.path}': there is a missing tag`);\n\n  return nodes;\n}\n\n//\nconst resolveNode = (node, json) => {\n  // resolve nested tags\n  if(node.nestedNodes.length > 0) {\n    node.nestedNodes.forEach(node => processNode(node, json));\n    node.content = joinContent(node.nestedNodes);\n  }\n\n  // process node so that content is resolved\n  const processor = nodeProcessors[node.type];\n\n  // There is a problem if we found no processor\n  if(!processor) {\n    console.warn(`WARNING while processing file '${node.file.path}': there is no processor for type '${node.type}'`);\n    return;\n  }\n\n  // load and resolve attribute values\n  node.attributes = loadNodeAttributes(node);\n\n  processor(node, json);\n}\n\n// loads values for tags into node object\nconst loadNodeAttributes = node => {\n  const attrs = nodeAttributes[node.type] || [];\n  return attrs.reduce((acc, attr) => {\n    if(hasTagAttribute(attr, node.originalContent)) {\n      const value = getTagAttribute(attr, node.originalContent);\n      acc[attr] = (attr === 'rawJson') ? processRawJson(value) : value;\n    }\n    return acc;\n  }, {})\n}\n\n// check for tag and return node type\nconst findNodeType = content => (\n  content.indexOf('<!--#insert')     === 0 ? 'insert'\n: content.indexOf('<!--#data')       === 0 ? 'data'\n: content.indexOf('<!--#jsonInsert') === 0 ? 'jsonInsert'\n: content.indexOf('<!--#wrap')       === 0 ? 'wrap'\n: content.indexOf('<!--#middle')     === 0 ? 'middle'\n: content.indexOf('<!--#each')       === 0 ? 'each'\n: content.indexOf('<!--#if')         === 0 ? 'if'\n: 'textContent'\n)\n\n//\nconst joinContent = nodeList => nodeList.map(c => c.content).join('')\n\n// the functions that processes each node\n// these assume that they have all their nested nodes resolved and attributes loaded\nconst nodeProcessors = {\n  //\n  topNode : (node, json) => node.content = joinContent(node.nestedNodes),\n  //\n  textContent : (node, json) => console.warn('WARNING: Why are we processing a textContent?'),\n  //\n  insert : (node, json) => {\n    const { file, innerScope } = node;\n    const { path, jsonPath, rawJson } = node.attributes;\n    if(!path) {\n      console.warn(`WARNING while processing file '${file.path}': insert tag with no path attribute`);\n      node.content = '';\n      return;\n    }\n\n    // get filename for inserted file\n    const filename = buildPathFromRelativePath(file.path, path);\n\n    // see if file we are loading exists\n    if(!insertFiles[filename]) {\n      console.warn(`WARNING while processing file '${file.path}': insert file '${filename}' does not exist`);\n      node.content = '';\n      return;\n    }\n\n    // load contents from file\n    const insertFile = { ...insertFiles[filename] };\n\n    // set scope for inserted file\n    const newInnerScope = (\n        rawJson    && jsonPath ? getDataFromJsonPath(jsonPath, rawJson)\n      : innerScope && jsonPath ? getDataFromJsonPath(jsonPath, innerScope)\n      : rawJson  ? rawJson\n      : jsonPath ? getDataFromJsonPath(jsonPath, json)\n      : void(0)\n    );\n\n    const insertNode = processFile(insertFile, json, node, newInnerScope);\n\n    // process contents to get children\n    node.content = insertNode.content;\n  },\n  //\n  wrap : (node, json) => {\n    const { file, innerScope } = node;\n    const { path, jsonPath, rawJson } = node.attributes;\n    if(!path) {\n      console.warn(`WARNING while processing file '${node.file.path}': wrap tag with no path attribute`);\n      node.content = '';\n      return;\n    }\n\n    // get filename for inserted file\n    const filename = buildPathFromRelativePath(file.path, path);\n\n    // see if file we are loading exists\n    if(!wrapFiles[filename]) {\n      console.warn(`WARNING while processing file '${node.file.path}': wrap file '${filename}' does not exist`);\n      node.content = '';\n      return;\n    }\n\n    // we need to process the children before we bring in the file\n\n    // handle children content\n    node.children.forEach(childNode => processNode(childNode, json))\n    node.content = joinContent(node.children);\n\n    // load contents from file\n    const wrapFile = { ...wrapFiles[filename] };\n\n    // set scope for inserted file\n    const newInnerScope = (\n        rawJson    && jsonPath ? getDataFromJsonPath(jsonPath, rawJson)\n      : innerScope && jsonPath ? getDataFromJsonPath(jsonPath, innerScope)\n      : rawJson  ? rawJson\n      : jsonPath ? getDataFromJsonPath(jsonPath, json)\n      : void(0)\n    );\n\n    const wrapNode = processFile(wrapFile, json, node, newInnerScope);\n\n    // process contents to get children\n    node.content = wrapNode.content;\n  },\n  //\n  middle : (node, json) => node.content = node.parent.parent.content,\n  //\n  data : (node, json) => {\n    const { innerScope, file } = node;\n    const { jsonPath, rawJson } = node.attributes;\n    const defaultVal = node.attributes.default;\n    if(!jsonPath || (!rawJson && !innerScope && !defaultVal)) {\n      console.warn(`WARNING while processing file '${file.path}': data tag with no data to look up for content '${node.originalContent}'`);\n      node.content = '';\n      return;\n    }\n    const values = rawJson || innerScope;\n    const data = getDataFromJsonPath(jsonPath, values);\n    node.content = data || defaultVal || '';\n  },\n  //\n  jsonInsert : (node, json) => {\n    const { jsonPath } = node.attributes;\n    const defaultVal = node.attributes.default;\n    if(!jsonPath) {\n      node.content = '';\n      return;\n    }\n    const data = getDataFromJsonPath(jsonPath, json);\n    node.content = data || defaultVal || '';\n  },\n  //\n  each : (node, json) => {\n    const { file, innerScope } = node;\n    const { count, jsonPath, rawJson } = node.attributes;\n    if(!count && !jsonPath && !Array.isArray(rawJson) && !Array.isArray(innerScope)) {\n      console.warn(`WARNING while processing file '${file.path}': each tag with attribute problems: count, jsonPath and rawJson and innerScope are not arrays`);\n      node.content = '';\n      return;\n    }\n\n    // determine what data we are using\n    const values = rawJson || node.innerScope || json;\n    const jsonData = jsonPath ? getDataFromJsonPath(jsonPath, values) : void(0);\n    const data = (\n        Array.isArray(values)   ? values\n      : Array.isArray(jsonData) ? jsonData\n      : void(0)\n    );\n\n    if(!data && !count) {\n      node.content = '';\n      return;\n    }\n\n    // build up nodes and bind the correct data\n    const tmpContent = [];\n    for(\n      let i = 0;\n         (!count || (count && i < count))\n      && (!data  || (data  && i < data.length));\n      i++)\n    {\n      // clone children\n      const tmpChildren = node.children.map(c => ({\n        ...c,\n        ...(data\n          ? {\n              innerScope : (typeof(data[i]) === 'object') ? { ...data[i] } : data[i]\n            }\n          : { }),\n      }))\n      // handle children content\n      tmpChildren.forEach(childNode => processNode(childNode, json))\n      tmpContent.push(joinContent(tmpChildren));\n    }\n\n    node.content = tmpContent.join('');\n  },\n  //\n  if : (node, json) => {\n    const { innerScope } = node;\n    const { jsonPath, rawJson } = node.attributes;\n    if(!jsonPath) {\n      node.content = '';\n      return;\n    }\n\n    const values = rawJson || innerScope || json;\n    const jsonData = getDataFromJsonPath(jsonPath, values);\n\n    if(!jsonData) {\n      node.content = '';\n      return;\n    }\n\n    node.children.forEach(childNode => {\n      childNode.innerScope = { ...node.innerScope };\n      processNode(childNode, json);\n    })\n    node.content = joinContent(node.children);\n  },\n}\n\n// the legal attributes for each element\nconst nodeAttributes = {\n  insert      : [ 'path', 'jsonPath', 'rawJson' ],\n  data        : [ 'jsonPath', 'rawJson', 'default' ],\n  jsonInsert  : [ 'jsonPath', 'default' ],\n  wrap        : [ 'path', 'jsonPath', 'rawJson' ],\n  middle      : [  ],\n  each        : [ 'count', 'jsonPath', 'rawJson' ],\n  if          : [ 'jsonPath', 'rawJson' ],\n  textContent : [  ],\n}\n\n// Splits a string into an array where special tags are on their own\n// can optionally only split it up based on a particular tag\nconst splitContent = (content, tag) => {\n  let arr = [],\n      openNdx = -1,\n      closeNdx = -1,\n      partial = \"\",\n      startPattern = tag || '<!--#',\n      endPattern = '-->';\n\n  //prime the loop\n  openNdx = content.indexOf(startPattern);\n\n  if(openNdx === -1)\n    return [content];\n\n  while(openNdx > -1) {\n    partial = content.slice(0, openNdx);\n    if(partial)\n      arr.push(partial);\n\n    content = content.slice(openNdx);\n\n    // get the closeNdx despite inner open tags\n    // openNdx-><!-- <!-- --> <!-- <!-- --> --> --><-closeNdx\n    let closeNdx = getIndexOfClosingBrace(content, startPattern, endPattern);\n\n    partial = content.slice(0, closeNdx);\n    arr.push(partial);\n    content = content.slice(closeNdx);\n\n    // get ready for next iteration\n    openNdx = content.indexOf(startPattern);\n\n    // on final pass, push the remainer of the content string\n    if(openNdx === -1)\n      arr.push(content);\n  }\n\n  // Now we have an array of tags, and content\n  return arr;\n}\n\n// Given some content (starting with a tag) find the index after the matching end tag\nconst getIndexOfClosingBrace = (content, startPattern, endPattern) => {\n  let tagDepth = 0;// when this gets to 0 we are done\n  let tmpContent = content.substr(1);\n\n\n  // prime loop by finding next start tag\n  let nextCloseNdx = tmpContent.indexOf(endPattern);\n  let nextOpenNdx = tmpContent.indexOf(startPattern);\n\n  if(nextCloseNdx ===  -1)\n    console.trace(`No Close tag for startPattern: ${startPattern} and endPattern: ${endPattern} and content: ${content}`);\n\n  // if there is a nextCloseNdx, but no openNdx, return the end of the tag.\n  if(nextOpenNdx === -1 || nextOpenNdx > nextCloseNdx)\n    return nextCloseNdx + 4; // 4 not 3 because we sliced off the '<' in content\n\n  // add 1 so we will search past the tag\n  nextOpenNdx += 1;\n  nextCloseNdx += 1;\n\n  // while current tag is not closed...\n  do {\n    let tmpOpen, tmpClosed;\n\n    // start tag is before close tag, then\n    // we can look to see if there is yet another tag nested between\n    if(nextOpenNdx > -1 && nextOpenNdx < nextCloseNdx) {\n      tmpOpen = tmpContent.substr(nextOpenNdx).indexOf(startPattern);\n      // see if we found something, and add this new index to our accumulator\n      if(tmpOpen > -1) {\n        // add 1 because we need next search to be beyond this tag\n        nextOpenNdx += tmpOpen + 2;\n        tagDepth += 1;\n      }\n      else\n        nextOpenNdx = -1;\n    }\n    else { // current close tag is before start tag\n      tmpClosed = tmpContent.substr(nextCloseNdx).indexOf(endPattern);\n      // see if we found something, and add this new index to our accumulator\n      if(tmpClosed > -1) {\n        // add 1 because we need next search to be beyond this tag\n        nextCloseNdx += tmpClosed + 1;\n        tagDepth -= 1;\n\n        if(tagDepth === 0)\n          return nextCloseNdx + 3;\n      }\n      else if(tagDepth > 0) {\n        console.error(`ERROR: there is an unclosed tag - content is ${content}`);\n        break;\n      }\n    }\n  } while(tagDepth > 0)\n\n  nextCloseNdx += 4;\n\n  if(nextCloseNdx === -1)\n    console.error(`ERROR: no closing tag! you are missing a '${endPattern}'`);\n\n  return nextCloseNdx;\n}\n\n// given a jsonObject and a path, return the data pointed at\nconst getDataFromJsonPath = (jsonPath, json) => {\n  if(jsonPath === 'this') return json;\n\n  let result = jsonPath.split('.').reduce((acc, cur) => acc ? acc[cur] : '', json)\n\n  if(!Array.isArray(result) && typeof(result) === 'object')\n    result = toSafeJsonString(result);\n\n  return result;\n}\n\n// are we on windows?\nconst isWin = /^win/.test(process.platform);\n\n// overcome the difference in *nix/windows pathing\nconst fixFilePathForOS = path =>\n  (isWin) ? path.replace(/\\//g, '\\\\') : path.replace(/\\\\/g, '/')\n\n// given the current directory and a relative path, build the complete path\n// to the relative path\nconst buildPathFromRelativePath = (cdir, fdir) => {\n  let dirChar = (isWin) ? '\\\\' : '/';\n  let dir = cdir.split(dirChar);\n  dir.pop();\n\n  fdir = fixFilePathForOS(fdir);\n\n  fdir.split(dirChar)\n    .forEach(function(e) {\n      (e === '..') ? dir.pop() : (e !== '.' && e !== '') ? dir.push(e) : void 0;\n    });\n  dir = dir.join(dirChar);\n\n  return dir;\n}\n\n//\nconst toSafeJsonString = jsonObj =>\n  JSON.stringify(jsonObj).replace(/\\'/g, \"\\\\'\").replace(/\"/g, \"'\")\n\n//\nconst processRawJson = jsonString => {\n  if(typeof(jsonString) === 'object')\n    jsonString = toSafeJsonString(jsonString);\n\n  let jsonData = {};\n  try {\n    eval('jsonData = ' + jsonString);\n  }\n  catch(e) {\n    console.error(`ERROR: Poorly formatted rawJson string:\n      ${jsonString}\n      This must be valid JavaScript.\n    `);\n  }\n\n  return jsonData;\n}\n\n// does a tag have an attribute? (attributeName=\"value\")\nconst hasTagAttribute =\n  (attr, content) => content.indexOf(attr + '=\"') > -1\n\n// get the value of an attribute (attributeName=\"value\")\nconst getTagAttribute = (attr, content) => {\n  let fndx = -1,\n      lndx = -1;\n\n  fndx = content.indexOf(attr + '=\"');\n  if(fndx === -1) {\n    console.warn(\"Warning: no tag of name `\" + attr + \"` found in the following content: `\" + content + \"`\")\n    return '';\n  }\n\n  content = content.slice(fndx + attr.length + 2);\n  lndx = content.indexOf('\"');\n  content = content.slice(0, lndx);\n  return content;\n}\n"],"sourceRoot":""}