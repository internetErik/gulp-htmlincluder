{"version":3,"file":"htmlincluder.js","mappings":"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","sources":["webpack://gulp-htmlincluder/./src/config.js","webpack://gulp-htmlincluder/./src/index.js","webpack://gulp-htmlincluder/./src/parse.js","webpack://gulp-htmlincluder/webpack/bootstrap","webpack://gulp-htmlincluder/webpack/runtime/define property getters","webpack://gulp-htmlincluder/webpack/runtime/harmony module decorator","webpack://gulp-htmlincluder/webpack/runtime/hasOwnProperty shorthand","webpack://gulp-htmlincluder/webpack/startup"],"sourcesContent":["export const wrapFiles = {};\nexport const insertFiles = {};\nexport const pageFiles = [];\n\nexport let options = {};\nexport let devOptions = {};\nexport let insertPattern;\nexport let filePathAttribute;\nexport let jsonPathAttribute;\n\nexport const configureFiles = file => {\n  if(file.name[0] === '_')\n    wrapFiles[file.path] = file;\n  else if(file.name[0] === '-')\n    insertFiles[file.path] = file;\n  else\n    pageFiles.push(file);\n}\n\n// @options = (optional) options for configuring htmlIncluder\n// options.jsonInput         = A json object used to populate data in files\n// options.insertPattern     = The test looked for in order to insert files\n//          (this is so ssi includes can be used instead)\n// options.filePathAttribute = the name used for the file pathing for #insert\n//          and #wrap (default= 'path')\n// options.jsonPathAttribute = the name used for the file pathing for #insert\n//          , #wrap, #data, #jsonInsert (default= 'jsonPath')\n//\n//\n// options.dev.limitIterations = the number of times processFileWithJsonInput will loop\n// options.dev.printIterations = console log each processFileWithJsonInput loop\n// options.dev.printResult = console logs the final output\n// options.dev.printPaths = console logs the output of buildPathFromRelativePath\nexport const setOptions = ops => {\n  devOptions = ops.dev || {};\n  options = ops;\n\n  //set text value for insert tags, or default\n  insertPattern = (options.insertPattern)\n    ? '<!--#' + options.insertPattern\n    : '<!--#insert';\n\n  filePathAttribute = (options.filePathAttribute)\n    ? options.filePathAttribute\n    : 'path';\n\n  jsonPathAttribute = (options.jsonPathAttribute)\n    ? options.jsonPathAttribute\n    : 'jsonPath';\n}\n","import { configureFiles, setOptions, pageFiles, options } from './config';\nimport { processFile } from './parse';\n\nmodule.exports = {\n  initialize : options => setOptions(options),\n  // puts files into hash maps\n  hashFile : file => {\n    const f = formatFile(file);\n\n    // removing clip right away does no damage and speeds up later processing\n    processClip(f);\n\n    configureFiles(f);\n  },\n  // map on page files and build them into strings\n  buildFileResult : callback => pageFiles.map(file => {\n    const processedFile = processFile(file, options.jsonInput || {});\n    file.content = processedFile.content;\n\n    file.processed = true;\n\n    if(callback)\n      callback(file);\n\n    return file;\n  }),\n};\n\nconst isWin = /^win/.test(process.platform);\n\nconst formatFile = file => {\n  let f = {\n    path : file.path,\n    content : file.contents.toString('utf8').trim(),\n    processed : false,\n    file : file,\n  };\n\n  f.name = (isWin) ? file.path.split('\\\\') : file.path.split('/');\n  f.name = f.name[f.name.length-1];\n\n  return f;\n}\n\n// This runs first, since all of the clipped areas will completely be removed\nconst processClip = file => {\n  // process clipbefore and clipafter\n  if(file.content.indexOf('<!--#clipbefore') > -1) {\n    file.content = file.content\n      .split(/<!--#clipbefore\\s*-->/)\n      .splice(1)[0]\n      .split('<!--#clipafter')\n      .splice(0,1)[0];\n  }\n\n  // process clipbetween\n  if(file.content.indexOf('<!--#clipbetween') > -1) {\n    const tmp = file.content.split(/<!--#clipbetween\\s*-->/);\n    file.content = tmp[0] + tmp[1].split(/<!--#endclipbetween\\s*-->/)[1];\n  }\n}\n","import {\n  jsonPathAttribute,\n  filePathAttribute,\n  insertFiles,\n  wrapFiles,\n  options,\n  devOptions,\n  insertPattern,\n} from './config';\n\n// shape of our AST nodes\nconst getDefaultNode = () => ({\n  type            : '',\n  file            : {},\n  originalContent : '',\n  content         : '',\n  parent          : {},\n  innerScope      : null,\n  children        : [], // list of sequential nodes wrapped in tag (or at topNode)\n  nestedNodes     : [], // nested tags - these need to be resolved before this tag is resolved\n  attributes      : {}, // attributes on tag\n})\n\n// entry point for processing files\nexport const processFile = (file, json, parent, innerScope) => {\n  // convert string into object\n  const topNode = {\n    ...getDefaultNode(),\n    type    : 'topNode',\n    file,\n    originalContent : file.content,\n    content : file.content,\n    ...(parent     ? { parent }     : {}),\n    ...(innerScope ? { innerScope } : {}),\n  };\n\n  // don't do work if there are no tags in the file\n  if(topNode.originalContent.indexOf('<!--#') === -1)\n    return topNode;\n\n  // process children of the node\n  processNode(topNode, json);\n\n  return topNode;\n}\n\n//\nconst processNode = (node, json) => {\n  if(node.type === 'textContent') return node;\n\n  // the contents of a node may contain more nested nodes\n  // break these up into an array of mixed textContent nodes and tags\n  const contentArr = splitContent(node.content).filter(c => c !== '');\n\n  // convert array of strings to nodes\n  node.nestedNodes = buildNodes(node, contentArr, json);\n\n  return resolveNode(node, json);\n}\n\n//\nconst buildNodes = (parent, contentArr, json, closeTag) => {\n  const nodes = [];\n\n  while(contentArr.length > 0) {\n    const content = contentArr.shift();\n\n    // if we find the close tag, then we are done with our search\n    if(closeTag && content.indexOf(closeTag) === 0)\n      return nodes;\n\n    // lookup type of the tag\n    const type = findNodeType(content);\n\n    const node = {\n      ...getDefaultNode(),\n      type,\n      parent,\n      file            : parent.file,\n      innerScope      : parent.innerScope,\n      originalContent : content,\n      content,\n    };\n\n    // if this is a text node, we're set\n    if(type === 'textContent') {\n      nodes.push(node);\n      continue;\n    }\n\n    // remove leading character ('<') so the inner contents can be parsed properly\n    node.content = node.originalContent.slice(1);\n\n    // the contents inside a node can be treated like new little documents\n\n    // if this is a node that has children build them up, removing them\n    // from the split up array\n    node.children = (\n        type === 'wrap' ? buildNodes(node, contentArr, json, '<!--#endwrap')\n      : type === 'each' ? buildNodes(node, contentArr, json, '<!--#endeach')\n      : type === 'if'   ? buildNodes(node, contentArr, json, '<!--#endif')\n      : []\n    );\n\n    nodes.push(node);\n  }\n\n  // We should never get here while looking for a closing tag\n  if(closeTag)\n    console.warn(`WARNING while processing file '${parent.file.path}': there is a missing tag`);\n\n  return nodes;\n}\n\n//\nconst resolveNode = (node, json) => {\n  // resolve nested tags\n  if(node.nestedNodes.length > 0) {\n    node.nestedNodes.forEach(node => processNode(node, json));\n    node.content = joinContent(node.nestedNodes);\n  }\n\n  // process node so that content is resolved\n  const processor = nodeProcessors[node.type];\n\n  // There is a problem if we found no processor\n  if(!processor) {\n    console.warn(`WARNING while processing file '${node.file.path}': there is no processor for type '${node.type}'`);\n    return node;\n  }\n\n  // load and resolve attribute values\n  node.attributes = loadNodeAttributes(node, json);\n\n  return processor(node, json);\n}\n\n// loads values for tags into node object\nconst loadNodeAttributes = (node, json) => {\n  const attrs = nodeAttributes[node.type] || [];\n  return attrs.reduce((acc, attr) => {\n    if(hasTagAttribute(attr, node.content)) {\n      const value = getTagAttribute(attr, node.content);\n      acc[attr] = (attr === 'rawJson') ? processRawJson(value, json) : value;\n    }\n    return acc;\n  }, {})\n}\n\n// check for tag and return node type\nconst findNodeType = content => (\n  content.indexOf('<!--#insert')     === 0 ? 'insert'\n: content.indexOf('<!--#data')       === 0 ? 'data'\n: content.indexOf('<!--#jsonInsert') === 0 ? 'jsonInsert'\n: content.indexOf('<!--#wrap')       === 0 ? 'wrap'\n: content.indexOf('<!--#middle')     === 0 ? 'middle'\n: content.indexOf('<!--#each')       === 0 ? 'each'\n: content.indexOf('<!--#if')         === 0 ? 'if'\n: 'textContent'\n)\n\n//\nconst joinContent = nodeList => nodeList.map(c => c.content).join('')\n\n// the functions that processes each node\n// these assume that they have all their nested nodes resolved and attributes loaded\nconst nodeProcessors = {\n  //\n  topNode : (node, json) => {\n    node.content = joinContent(node.nestedNodes)\n    return node;\n  },\n  //\n  textContent : (node, json) => {\n    console.warn('WARNING: Why are we processing a textContent?');\n    return node;\n  },\n  //\n  insert : (node, json) => {\n    const { file, innerScope } = node;\n    const { path, jsonPath, rawJson } = node.attributes;\n    if(!path) {\n      console.warn(`WARNING while processing file '${file.path}': insert tag with no path attribute`);\n      node.content = '';\n      return node;\n    }\n\n    // get filename for inserted file\n    const filename = buildPathFromRelativePath(file.path, path);\n\n    // see if file we are loading exists\n    if(!insertFiles[filename]) {\n      console.warn(`WARNING while processing file '${file.path}': insert file '${filename}' does not exist`);\n      node.content = '';\n      return node;\n    }\n\n    // load contents from file\n    const insertFile = { ...insertFiles[filename] };\n\n    // set scope for inserted file\n    const newInnerScope = (\n        rawJson    && jsonPath ? getDataFromJsonPath(jsonPath, rawJson)\n      : innerScope && jsonPath ? getDataFromJsonPath(jsonPath, innerScope)\n      : rawJson  ? rawJson\n      : jsonPath ? getDataFromJsonPath(jsonPath, json)\n      : void(0)\n    );\n\n    const insertNode = processFile(insertFile, json, node, newInnerScope);\n\n    // process contents to get children\n    node.content = insertNode.content;\n    return node;\n  },\n  //\n  wrap : (node, json) => {\n    const { file, innerScope } = node;\n    const { path, jsonPath, rawJson } = node.attributes;\n    if(!path) {\n      console.warn(`WARNING while processing file '${node.file.path}': wrap tag with no path attribute`);\n      node.content = '';\n      return node;\n    }\n\n    // get filename for inserted file\n    const filename = buildPathFromRelativePath(file.path, path);\n\n    // see if file we are loading exists\n    if(!wrapFiles[filename]) {\n      console.warn(`WARNING while processing file '${node.file.path}': wrap file '${filename}' does not exist`);\n      node.content = '';\n      return node;\n    }\n\n    // we need to process the children before we bring in the file\n\n    // handle children content\n    node.children = node.children.map(childNode => processNode(childNode, json))\n    node.content = joinContent(node.children);\n\n    // load contents from file\n    const wrapFile = { ...wrapFiles[filename] };\n\n    // set scope for inserted file\n    const newInnerScope = (\n        rawJson    && jsonPath ? getDataFromJsonPath(jsonPath, rawJson)\n      : innerScope && jsonPath ? getDataFromJsonPath(jsonPath, innerScope)\n      : rawJson  ? rawJson\n      : jsonPath ? getDataFromJsonPath(jsonPath, json)\n      : void(0)\n    );\n\n    const wrapNode = processFile(wrapFile, json, node, newInnerScope);\n\n    // process contents to get children\n    node.content = wrapNode.content;\n    return node;\n  },\n  //\n  middle : (node, json) => {\n    node.content = node.parent.parent.content\n    return node;\n  },\n  //\n  data : (node, json) => {\n    const { innerScope, file } = node;\n    const { jsonPath, rawJson } = node.attributes;\n    const defaultVal = node.attributes.default;\n\n    if(!jsonPath || (!rawJson && !innerScope && !defaultVal)) {\n      console.warn(`WARNING while processing file '${file.path}': data tag with no data to look up for content '${node.originalContent}'`);\n      node.content = '';\n      return node;\n    }\n    const values = rawJson || innerScope;\n    const data = getDataFromJsonPath(jsonPath, values);\n    node.content = data || defaultVal || '';\n    return node;\n  },\n  //\n  jsonInsert : (node, json) => {\n    const { jsonPath } = node.attributes;\n    const defaultVal = node.attributes.default;\n    if(!jsonPath) {\n      node.content = '';\n      return node;\n    }\n    const data = getDataFromJsonPath(jsonPath, json);\n    node.content = data || defaultVal || '';\n    return node;\n  },\n  //\n  each : (node, json) => {\n    const { file, innerScope } = node;\n    const { count, jsonPath, rawJson } = node.attributes;\n    if(!count && !jsonPath && !Array.isArray(rawJson) && !Array.isArray(innerScope)) {\n      console.warn(`WARNING while processing file '${file.path}': each tag with attribute problems: count, jsonPath and rawJson and innerScope are not arrays`);\n      node.content = '';\n      return node;\n    }\n\n    // determine what data we are using\n    const values = rawJson || node.innerScope || json;\n    const jsonData = jsonPath ? getDataFromJsonPath(jsonPath, values) : void(0);\n    const data = (\n        Array.isArray(values)   ? values\n      : Array.isArray(jsonData) ? jsonData\n      : void(0)\n    );\n\n    if(!data && !count) {\n      node.content = '';\n      return node;\n    }\n\n    // build up nodes and bind the correct data\n    const tmpContent = [];\n    for(\n      let i = 0;\n         (!count || (count && i < count))\n      && (!data  || (data  && i < data.length));\n      i++)\n    {\n      // clone children\n      let tmpChildren = node.children.map(c => ({\n        ...c,\n        ...(c.nestedNodes ? { nestedNodes : c.nestedNodes} : { }),\n        ...(c.children    ? { children : c.children } : { }),\n        ...(data\n          // ? { innerScope : (typeof(data[i]) === 'object') ? { ...data[i] } : data[i] }\n          ? { innerScope : data[i] }\n          : { }\n        ),\n      }))\n      // handle children content\n      tmpChildren = tmpChildren.map(childNode => processNode(childNode, json))\n      tmpContent.push(joinContent(tmpChildren));\n    }\n\n    node.content = tmpContent.join('');\n    return node;\n  },\n  //\n  if : (node, json) => {\n    const { innerScope } = node;\n    const { jsonPath, rawJson } = node.attributes;\n    if(!jsonPath) {\n      node.content = '';\n      return node;\n    }\n\n    const values = rawJson || innerScope || json;\n    const jsonData = getDataFromJsonPath(jsonPath, values);\n    if(!jsonData) {\n      node.content = '';\n      return node;\n    }\n    node.children = node.children.map(childNode => {\n      return processNode({\n        ...childNode,\n        innerScope : { ...node.innerScope }\n      }, json);\n    })\n    node.content = joinContent(node.children);\n    return node;\n  },\n}\n\n// the legal attributes for each element\nconst nodeAttributes = {\n  insert      : [ 'path', 'jsonPath', 'rawJson' ],\n  data        : [ 'jsonPath', 'rawJson', 'default' ],\n  jsonInsert  : [ 'jsonPath', 'default' ],\n  wrap        : [ 'path', 'jsonPath', 'rawJson' ],\n  middle      : [  ],\n  each        : [ 'count', 'jsonPath', 'rawJson' ],\n  if          : [ 'jsonPath', 'rawJson' ],\n  textContent : [  ],\n}\n\nconst getTagPositions = (tag, content, lndx = 0, ndx = content.indexOf(tag)) => (\n  (ndx === -1)\n? []\n: [ ndx + lndx, ...getTagPositions(tag, content.slice(ndx + 1), lndx + ndx + 1) ]\n)\n\nconst buildTagPairs = (open, close) => (\n    (open.length === 0) ? []\n  : (open.length === 1 || open[1] > close[0]) ? [[open.slice(0, 1)[0], close.slice(0, 1)[0]], ...buildTagPairs(open.slice(1), close.slice(1))]\n  : [ ...buildTagPairs([...open.slice(0,1), ...open.slice(2)], close.slice(1)) ]\n)\n\nconst divideContent = (content, [start, end], pairs, cursor = 0) => (\n  (start === void(0))\n? [ content.slice(cursor) ]\n: [\n    content.slice(cursor, start),\n    content.slice(start, end+3),\n    ...divideContent(content, pairs.shift() || [], pairs, end+3),\n  ]\n)\n\nconst splitContent = content => {\n  const openTags  = getTagPositions('<!--#', content);\n  const closeTags = getTagPositions('-->', content);\n\n  if(openTags.length < closeTags.length) closeTags.pop();\n\n  const pairs = buildTagPairs(openTags, closeTags);\n\n  return divideContent(content, pairs.shift() || [], pairs).filter(c => c !== '');\n}\n\n// given a jsonObject and a path, return the data pointed at\nconst getDataFromJsonPath = (jsonPath, json) => {\n  if(jsonPath === 'this') return json;\n\n  let result = jsonPath.split('.').reduce((acc, cur) => acc ? acc[cur] : '', json)\n\n  if(!Array.isArray(result) && typeof(result) === 'object')\n    result = toSafeJsonString(result);\n\n  return result;\n}\n\n// are we on windows?\nconst isWin = /^win/.test(process.platform);\n\n// overcome the difference in *nix/windows pathing\nconst fixFilePathForOS = path =>\n  (isWin) ? path.replace(/\\//g, '\\\\') : path.replace(/\\\\/g, '/')\n\n// given the current directory and a relative path, build the complete path\n// to the relative path\nconst buildPathFromRelativePath = (cdir, fdir) => {\n  let dirChar = (isWin) ? '\\\\' : '/';\n  let dir = cdir.split(dirChar);\n  dir.pop();\n\n  fdir = fixFilePathForOS(fdir);\n\n  fdir.split(dirChar)\n    .forEach(function(e) {\n      (e === '..') ? dir.pop() : (e !== '.' && e !== '') ? dir.push(e) : void 0;\n    });\n  dir = dir.join(dirChar);\n\n  return dir;\n}\n\n//\nconst toSafeJsonString = jsonObj =>\n  JSON.stringify(jsonObj).replace(/\\'/g, \"\\\\'\").replace(/\"/g, \"'\")\n\n//\nconst processRawJson = (jsonString, json) => {\n  if(typeof(jsonString) === 'object')\n    jsonString = toSafeJsonString(jsonString);\n\n  let jsonData = {};\n  try {\n    eval('jsonData = ' + jsonString);\n  }\n  catch(e) {\n    console.error(`ERROR: Poorly formatted rawJson string:\n      ${jsonString}\n      This must be valid JavaScript.\n    `);\n  }\n\n  return jsonData;\n}\n\n// does a tag have an attribute? (attributeName=\"value\")\nconst hasTagAttribute = (attr, content) => content.indexOf(attr + '=\"') > -1\n\n// get the value of an attribute (attributeName=\"value\")\nconst getTagAttribute = (attr, content) => {\n  let fndx = -1,\n      lndx = -1;\n\n  fndx = content.indexOf(attr + '=\"');\n  if(fndx === -1) {\n    console.warn(\"Warning: no tag of name `\" + attr + \"` found in the following content: `\" + content + \"`\")\n    return '';\n  }\n\n  content = content.slice(fndx + attr.length + 2);\n  lndx = content.indexOf('\"');\n  content = content.slice(0, lndx);\n  return content;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.hmd = (module) => {\n\tmodule = Object.create(module);\n\tif (!module.children) module.children = [];\n\tObject.defineProperty(module, 'exports', {\n\t\tenumerable: true,\n\t\tset: () => {\n\t\t\tthrow new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);\n\t\t}\n\t});\n\treturn module;\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(352);\n"],"names":["wrapFiles","insertFiles","pageFiles","options","configureFiles","file","name","path","push","setOptions","ops","dev","insertPattern","filePathAttribute","jsonPathAttribute","exports","initialize","hashFile","f","formatFile","processClip","buildFileResult","callback","processedFile","processFile","content","processed","isWin","test","process","platform","contents","toString","trim","split","length","indexOf","splice","tmp","getDefaultNode","type","originalContent","parent","innerScope","children","nestedNodes","attributes","json","topNode","processNode","node","contentArr","splitContent","filter","c","buildNodes","resolveNode","closeTag","nodes","shift","findNodeType","slice","console","warn","forEach","joinContent","processor","nodeProcessors","loadNodeAttributes","nodeAttributes","reduce","acc","attr","hasTagAttribute","value","getTagAttribute","processRawJson","nodeList","map","join","textContent","insert","jsonPath","rawJson","filename","buildPathFromRelativePath","insertFile","newInnerScope","getDataFromJsonPath","insertNode","wrap","childNode","wrapFile","wrapNode","middle","data","defaultVal","jsonInsert","each","count","Array","isArray","values","jsonData","tmpContent","i","tmpChildren","if","getTagPositions","tag","lndx","ndx","buildTagPairs","open","close","divideContent","pairs","start","end","cursor","openTags","closeTags","pop","result","cur","toSafeJsonString","fixFilePathForOS","replace","cdir","fdir","dirChar","dir","e","jsonObj","JSON","stringify","jsonString","eval","error","fndx","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","module","id","loaded","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","hmd","create","set","Error","obj","prop","prototype","hasOwnProperty","call","__webpack_exports__"],"sourceRoot":""}